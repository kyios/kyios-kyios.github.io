<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[ios Runtime 总结]]></title>
    <url>%2F2019%2F01%2F12%2Fios-Runtime-%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[Runtime: 是基于c的api,是iOS内部的核心之一,底层都是基于它来实现的,oc是一门动态语言,在编译后好多类和对象是编译器不知道的,这时候需要运行时系统(runtime-system)来处理编译后的代码. [TOC] Runtime消息传递方法调用在OC中方法都是通过Runtime实现的。下面效果是相同的12345678TestClass * test = [[TestClass alloc] init];//----------------------------------------[test testfun];((SEL (*)(id, SEL))(void *)objc_msgSend)((id)test, @selector(testfun));//----------------------------------------//方法带参数[test testfunArg1:333 Arg2:@&quot;abcd&quot;];((void (*)(id, SEL, long double , NSString *))(void *) objc_msgSend)((id)test, @selector(testfunArg1:Arg2:), 333 ,@&quot;abcd&quot;); 12//类方法调用objc_msgSend(objc_getClass(&quot;TestClass&quot;), sel_registerName(&quot;alloc&quot;)); 项目中不同的类声明不同的方法，SEL 是同一个 123456789TestClass * test = [[TestClass alloc] init];[test testfun]; TestClass2 * test2 = [[TestClass2 alloc] init];[test2 testfun];//打印结果TestObject testMethod 0x1097799f2TestObject testMethod 0x1097799f2 Runtime 中维护了一个SEL的表。这个表不按类来存储。只要SEL相同就当做同一个，存储到表中。项目加载的时候所有的方法都会加载到这个表中，动态生成的方法也就加载到表中。 12345static struct /*_method_list_t*/ &#123; unsigned int entsize; // sizeof(struct _objc_method) unsigned int method_count; struct _objc_method method_list[3];&#125; 隐藏参数常用的2个隐藏参数 self _cmd 12345678910111213141516171819202122@interface TestClass : NSObject&#123; int testVal ;&#125;@end//oc 类@implementation TestClass- (instancetype)init&#123; self = [super init]; if (self) &#123; &#125; return self;&#125;- (void)testfun:(NSString *)string&#123;&#125;void testCfun(int abc)&#123;//如果调用类里面函数的全局变量 testVal = 10; //build error Use of undeclared identifier &apos;testVal&apos;&#125;@end 1234567891011121314转换后static instancetype _I_TestClass_init(TestClass * self, SEL _cmd) &#123; self = ((TestClass *(*)(__rw_objc_super *, SEL))(void *)objc_msgSendSuper)((__rw_objc_super)&#123;(id)self, (id)class_getSuperclass(objc_getClass(&quot;TestClass&quot;))&#125;, sel_registerName(&quot;init&quot;)); if (self) &#123; &#125; return self;&#125;static void _I_TestClass_testfun_(TestClass * self, SEL _cmd, NSString *__strong string) &#123;&#125;void testCfun(int abc)&#123;&#125; 123456789[[TestClass alloc] init];//会转换成TestClass * test = ((TestClass *(*)(id, SEL))(void *)objc_msgSend)((id)((TestClass *(*)(id, SEL))(void *)objc_msgSend)((id)objc_getClass(&quot;TestClass&quot;), sel_registerName(&quot;alloc&quot;)), sel_registerName(&quot;init&quot;));/*** 相当于* id test = objc_msgSend(objc_getClass(&quot;TestClass&quot;),sel_registerName(&quot;alloc&quot;));* objc_msgSend(test, sel_registerName(&quot;init&quot;));*/ Tips 我们可以通过下面三种方法来获取SEL: sel_registerName函数 Objective-C编译器提供的@selector() NSSelectorFromString()方法 得到结论：oc 经过转换后，每个oc 的方法都会带有target，SEL，和参数。方法 调动的时候 会携带 target 和方法参数等。target 就是self，方法名就是_cmd由于C方法没有携带target，所以无法使用类的全局变量 12345678910111213141516171819202122@implementation TestClass- (instancetype)init&#123; self = [super init]; if (self) &#123; &#125; return self;&#125;- (void)testfun:(NSString *)string&#123; printf(&quot;%s\n&quot;, [[[self class] description] UTF8String]); printf(&quot;%s\n&quot; ,[[[super class] description] UTF8String]); printf(&quot;%s\n&quot; ,[[[self superclass] description]UTF8String]); printf(&quot;%s\n&quot; ,[[[TestClass superclass] description]UTF8String]);&#125;@end//打印结果TestClassTestClassNSObjectNSObject 执行的源码 1234567Class a1 = ((Class (*)(id, SEL))(void *)objc_msgSend)((id)self, sel_registerName(&quot;class&quot;));Class a2 = ((Class (*)(__rw_objc_super *, SEL))(void *)objc_msgSendSuper)((__rw_objc_super)&#123;(id)self, (id)class_getSuperclass(objc_getClass(&quot;TestClass&quot;))&#125;, sel_registerName(&quot;class&quot;)); Class a3 = ((Class (*)(id, SEL))(void *)objc_msgSend)((id)self, sel_registerName(&quot;superclass&quot;)); Class a4 = ((Class (*)(id, SEL))(void *)objc_msgSend)((id)objc_getClass(&quot;TestClass&quot;), sel_registerName(&quot;superclass&quot;)); 第二行为什么不是NSObject objc_msgSendSuper id objc_msgSendSuper(struct objc_super *super, SEL op, …) super 获取是传入实例和父类的class。生成的结构体如下 1234struct objc_super &#123; id receiver; Class superClass; &#125;; SEL 要执行的方法 比如第二次获取。要执行SEL objc_msgSendSuper 执行 class 方法。是从 objc_super-&gt;superClass 的方法列表开始找SEL，然后 objc_super-&gt; receiver 来执行这个方法。由此可知 super 不管执行什么objc_super-&gt;superClass 都是 self但是 objc_super 在执行方法过程中 superClass 搜索方法列表是从 objc_super-&gt;superClass 开始的。比如 self super 都包含 - (void)testfun:(NSString *)string。方法直接执行父类的方法 结论:super实际作用就是self 来执行父类的方法。如果父类没有，子类有相应的方法，程序直接回报错 方法执行（消息发送流程）当对象创建的时候，完成初始化的时候，对象的第一个变量的指针*isa,*isa可以访问类的对象，并且可以通过对象来访问既继承链中的类。 当执行方法过程中，消息随着对象的*isa指针到类的结构体中，在method list 查找方法，找不到就沿着继承一直上找，知道NSObject。 objc_msgsend 发送消息过程中，同一个方法第一次是没有缓存的，使用后就会缓存。之后直接调用缓存。 查找方法首先从缓存里面查找。不会立即查看methodLists,优先查找缓存。 123456789101112struct objc_class &#123; Class _Nonnull isa ; Class _Nullable super_class; const char * _Nonnull name; long version; long info; long instance_size; struct objc_ivar_list * _Nullable ivars; struct objc_method_list * _Nullable * _Nullable methodLists; struct objc_cache * _Nonnull cache; struct objc_protocol_list * _Nullable protocols;&#125; OBJC2_UNAVAILABLE; 12345678910111213struct objc_cache &#123; unsigned int mask /* total = mask + 1 */ OBJC2_UNAVAILABLE; unsigned int occupied OBJC2_UNAVAILABLE; Method _Nullable buckets[1] OBJC2_UNAVAILABLE;&#125;;typedef struct method_t *Method;struct method_t &#123; SEL name; const char *types; IMP imp;&#125;; objc_msgSend_c 执行前判断 123456789101112131415161718id objc_msgSend_c(id obj, SEL sel,...) &#123; id localObj = obj; int64_t obj_i = (int64_t)obj; //这一部分处理tagged pointer的isa指针 if (obj_i == 0) return nil; if (obj_i &lt; 0) &#123; //tagged pointer uintptr_t obj_ui = (uintptr_t)obj_i; if (obj_ui &gt;= _OBJC_TAG_EXT_MASK) &#123; uint16_t index = (obj_ui &lt;&lt; _OBJC_TAG_PAYLOAD_LSHIFT) &gt;&gt; (_OBJC_TAG_EXT_INDEX_SHIFT + _OBJC_TAG_PAYLOAD_LSHIFT); localObj = objc_tag_ext_classes[index]; &#125; else &#123; uint16_t index = obj_ui &gt;&gt; _OBJC_TAG_INDEX_SHIFT; localObj = objc_tag_classes[index]; &#125; &#125; &#125; lookUpImpOrForward 负责查找IMP和转发代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106IMP lookUpImpOrForward(Class cls, SEL sel, id inst, bool initialize, bool cache, bool resolver)&#123; IMP imp = nil; bool triedResolver = NO; runtimeLock.assertUnlocked(); // 缓存中加载IMP， if (cache) &#123; imp = cache_getImp(cls, sel); if (imp) return imp; &#125; runtimeLock.read(); //判断类是否被创建，如果没有被创建，实例化 if (!cls-&gt;isRealized()) &#123; runtimeLock.unlockRead(); runtimeLock.write(); realizeClass(cls); runtimeLock.unlockWrite(); runtimeLock.read(); &#125; if (initialize &amp;&amp; !cls-&gt;isInitialized()) &#123; runtimeLock.unlockRead(); _class_initialize (_class_getNonMetaClass(cls, inst)); runtimeLock.read(); &#125; retry: runtimeLock.assertReading(); // Try this class&apos;s cache.尝试获取这个类的缓存 imp = cache_getImp(cls, sel); if (imp) goto done; // TrP this class&apos;s method lists.没有获取到缓存 &#123; //方法列表中获取对应的Method，加入缓存获取IMP Method meth = getMethodNoSuper_nolock(cls, sel); if (meth) &#123; log_and_fill_cache(cls, meth-&gt;imp, sel, inst, cls); imp = meth-&gt;imp; goto done; &#125; &#125; // Try superclass caches and method lists.尝试父类缓存和方法列表中获取 &#123; unsigned attempts = unreasonableClassCount(); for (Class curClass = cls-&gt;superclass; curClass != nil; curClass = curClass-&gt;superclass) &#123; // Halt if there is a cycle in the superclass chain. if (--attempts == 0) &#123; _objc_fatal(&quot;Memory corruption in class list.&quot;); &#125; // Superclass cache. imp = cache_getImp(curClass, sel); if (imp) &#123; if (imp != (IMP)_objc_msgForward_impcache) &#123; // Found the method in a superclass. Cache it in this class. log_and_fill_cache(cls, imp, sel, inst, curClass); goto done; &#125; else &#123; // Found a forward:: entry in a superclass. // Stop searching, but don&apos;t cache yet; call method // resolver for this class first. break; &#125; &#125; // Superclass method list. Method meth = getMethodNoSuper_nolock(curClass, sel); if (meth) &#123; log_and_fill_cache(cls, meth-&gt;imp, sel, inst, curClass); imp = meth-&gt;imp; goto done; &#125; &#125; &#125; // No implementation found. Try method resolver once. // 消息转发模式，没有查到可执行的IMP，尝试动态解析 if (resolver &amp;&amp; !triedResolver) &#123; runtimeLock.unlockRead(); _class_resolveMethod(cls, sel, inst); runtimeLock.read(); // Don&apos;t cache the result; we don&apos;t hold the lock so it may have // changed already. Re-do the search from scratch instead. triedResolver = YES; goto retry; &#125; // No implementation found, and method resolver didn&apos;t help. // Use forwarding. // 如果IMP没有找到，动态解析也没有处理，进入消息转发阶段 imp = (IMP)_objc_msgForward_impcache; cache_fill(cls, sel, imp, inst); done: runtimeLock.unlockRead(); return imp;&#125; _class_resolveMethod1234567891011121314151617181920212223/************************************************************************ _class_resolveMethod* Call +resolveClassMethod or +resolveInstanceMethod.* Returns nothing; any result would be potentially out-of-date already.* Does not check if the method already exists.**********************************************************************/void _class_resolveMethod(Class cls, SEL sel, id inst)&#123; if (! cls-&gt;isMetaClass()) &#123; // try [cls resolveInstanceMethod:sel] _class_resolveInstanceMethod(cls, sel, inst); &#125; else &#123; // try [nonMetaClass resolveClassMethod:sel] // and [cls resolveInstanceMethod:sel] _class_resolveClassMethod(cls, sel, inst); if (!lookUpImpOrNil(cls, sel, inst, NO/*initialize*/, YES/*cache*/, NO/*resolver*/)) &#123; _class_resolveInstanceMethod(cls, sel, inst); &#125; &#125;&#125; _class_resolveInstanceMethod12345678910111213141516171819202122232425262728293031323334static void _class_resolveInstanceMethod(Class cls, SEL sel, id inst)&#123; if (! lookUpImpOrNil(cls-&gt;ISA(), SEL_resolveInstanceMethod, cls, NO/*initialize*/, YES/*cache*/, NO/*resolver*/)) &#123; // Resolver not implemented. return; &#125; BOOL (*msg)(Class, SEL, SEL) = (typeof(msg))objc_msgSend; bool resolved = msg(cls, SEL_resolveInstanceMethod, sel); // Cache the result (good or bad) so the resolver doesn&apos;t fire next time. // +resolveInstanceMethod adds to self a.k.a. cls IMP imp = lookUpImpOrNil(cls, sel, inst, NO/*initialize*/, YES/*cache*/, NO/*resolver*/); if (resolved &amp;&amp; PrintResolving) &#123; if (imp) &#123; _objc_inform(&quot;RESOLVE: method %c[%s %s] &quot; &quot;dynamically resolved to %p&quot;, cls-&gt;isMetaClass() ? &apos;+&apos; : &apos;-&apos;, cls-&gt;nameForLogging(), sel_getName(sel), imp); &#125; else &#123; // Method resolver didn&apos;t add anything? _objc_inform(&quot;RESOLVE: +[%s resolveInstanceMethod:%s] returned YES&quot; &quot;, but no new implementation of %c[%s %s] was found&quot;, cls-&gt;nameForLogging(), sel_getName(sel), cls-&gt;isMetaClass() ? &apos;+&apos; : &apos;-&apos;, cls-&gt;nameForLogging(), sel_getName(sel)); &#125; &#125;&#125; 1234567891011/************************************************************************ lookUpImpOrNil.* Like lookUpImpOrForward, but returns nil instead of _objc_msgForward_impcache**********************************************************************/IMP lookUpImpOrNil(Class cls, SEL sel, id inst, bool initialize, bool cache, bool resolver)&#123; IMP imp = lookUpImpOrForward(cls, sel, inst, initialize, cache, resolver); if (imp == _objc_msgForward_impcache) return nil; else return imp;&#125; 总结:调用objc_msgSend后，逻辑判断 接收对象为nil,消息无效 (objc_msgSend_c) 通过对象类的方法缓存里面查找（cache_getImp），如果有缓存直接返回IMP 查找类的method list,查找有对应的SEL 对象，有的话获取Method 对象，获取Method 的IMP。并加入缓存。 如果没有查找到，查询父类 ，重复 3，直至 NSObject 如果始终获取不到。进入动态解析。_class_resolveMethod ，会检测如果是类方法 _class_resolveClassMethod,成员方法 _class_resolveInstanceMethod,进入动态解析。 如果IMP没有找到，动态解析也没有处理，进入消息转发阶段。如果不错处理，就会crash 下图是实际工作中的消息转发。 加载过程IOS 动态库都是动态加载的。程序开始的时候才会链接动态库 APP 启动加载 系统先读取App 的可执行文件，里面获取dyld路径。 dyld初始化运行环境，开启缓存策略，加载相关依赖库和可执行文件，依赖库的初始化。 dyld将可执行文件以及相应的依赖库与插入库加载进内存生成对应的ImageLoader类的image(镜像文件)对象，对这些image进行链接，调用各image的初始化方法等(递归调用) 等待全部初始后，Runtime也初始化完成，会收到调用相关的回调。 Runtime对类进行类结构初始化。让后调用+load 执行main dyld 通过Mach-O文件查看器MachOView查看一个项目可执行文件 程序需要的dyld的路径在LC_LOAD_DY_LINKER命令里，一般都是在/usr/lib/dyld 路径下。这里的LC_MAIN指的是程序main函数加载地址，下面还有写LC_LOAD_DYLIB指向的都是程序依赖库加载信息，如果我们程序里使用到了AFNetworking，这里就会多一条名为LC_LOAD_DYLIB(AFNetworking)的命令 Runtime对类进行类结构初始化 Runtime实例化 _objc_init 调用 调用_dyld_objc_notify_register开始实例化 调用load_images 加载镜像 load_images 里面调用 call_load_methods call_load_methods 调用 call_class_loads 开始调用 class 和 category 的+load方法 第一次属于类的方法调用 调用 initialize,如果不调用永远不会调用 12345678910111213static void schedule_class_load(Class cls)&#123; if (!cls) return; assert(cls-&gt;isRealized()); // _read_images should realize if (cls-&gt;data()-&gt;flags &amp; RW_LOADED) return; // Ensure superclass-first ordering schedule_class_load(cls-&gt;superclass); add_class_to_loadable_list(cls); cls-&gt;setInfo(RW_LOADED); &#125; +load 是在初始化时候调用，main 所有实例化后才会调用。类的方法+load 遍历所有的子类都加入。父类的在前。category 直接添加 Category 在Category添加属性后，默认是没有实现方法的。当时编译不会错。调用会崩溃。 12Property &apos;object&apos; requires method &apos;object&apos; to be defined - use @dynamic or provide a method implementation in this category 下面是保存属性的方法1234567891011121314151617181920212223242526272829303132333435363738394041424344void _object_set_associative_reference(id object, void *key, id value, uintptr_t policy) &#123; // retain the new value (if any) outside the lock. ObjcAssociation old_association(0, nil); id new_value = value ? acquireValue(value, policy) : nil; &#123; AssociationsManager manager; AssociationsHashMap &amp;associations(manager.associations()); disguised_ptr_t disguised_object = DISGUISE(object); if (new_value) &#123; // break any existing association. AssociationsHashMap::iterator i = associations.find(disguised_object); if (i != associations.end()) &#123; // secondary table exists ObjectAssociationMap *refs = i-&gt;second; ObjectAssociationMap::iterator j = refs-&gt;find(key); if (j != refs-&gt;end()) &#123; old_association = j-&gt;second; j-&gt;second = ObjcAssociation(policy, new_value); &#125; else &#123; (*refs)[key] = ObjcAssociation(policy, new_value); &#125; &#125; else &#123; // create the new association (first time). ObjectAssociationMap *refs = new ObjectAssociationMap; associations[disguised_object] = refs; (*refs)[key] = ObjcAssociation(policy, new_value); object-&gt;setHasAssociatedObjects(); &#125; &#125; else &#123; // setting the association to nil breaks the association. AssociationsHashMap::iterator i = associations.find(disguised_object); if (i != associations.end()) &#123; ObjectAssociationMap *refs = i-&gt;second; ObjectAssociationMap::iterator j = refs-&gt;find(key); if (j != refs-&gt;end()) &#123; old_association = j-&gt;second; refs-&gt;erase(j); &#125; &#125; &#125; &#125; // release the old value (outside of the lock). if (old_association.hasValue()) ReleaseValue()(old_association);&#125; 对象都存入 AssociationsHashMap中 Runtime 应用指令的应用 __attribute__ 用法 允许增加参数，做一些高级检查和优化 objc_subclassing_restricted 不能被继承 123__attribute__((objc_subclassing_restricted)) @interface TestObject : NSObject@end objc_requires_super 子类必须实现父类的方法，否则警告 1- (void)testMethod __attribute__((objc_requires_super)); constructor / destructor main函数前后执行,__attribute__((constructor(101))) 添加优先级 1234__attribute__((constructor)) static void beforeMain() &#123; NSLog(@&quot;before main&quot;);&#125;__attribute__((destructor)) static void afterMain() &#123; NSLog(@&quot;after main&quot;);&#125; overloadable 可重复方法名 123__attribute__((overloadable)) void testMethod(int age) &#123;&#125; __attribute__((overloadable)) void testMethod(NSString *name) &#123;&#125; __attribute__((overloadable)) void testMethod(BOOL gender) &#123;&#125; cleanup 释放变量前执行 1234TestObject *object __attribute__((cleanup(releaseBefore))) = [[TestObject alloc] init];static void releaseBefore(NSObject **object) &#123; NSLog(@&quot;%@&quot;, *object);&#125; ORM对象的映射关系]]></content>
      <categories>
        <category>Runtime</category>
      </categories>
      <tags>
        <tag>IOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Objective C 特性]]></title>
    <url>%2F2019%2F01%2F11%2FObjective-C%2F</url>
    <content type="text"><![CDATA[Objective C 特性分类功能 生命私有方法 分解体积庞大的类文件 把Framework的私有方法公开化 特点 运行时决议，编写完成后没有附加到宿主类中，没有对应的方法，运行时添加到响应的宿主上 可以为系统类添加分类 分类添加的方法回覆盖原类方法（原类方法依然存在） 同名方法谁能生效取决于编译顺序 名字相同的分类会引起编译器报错 分类中可以添加 实例方法 类方法 类属性（只是声明了set get 方法，没有相应的变量） 协议 分类的源码，实际是创建的分类文件1234567891011121314151617struct category_t &#123; const char *name;//分类的名称 classref_t cls;//所属宿主类 struct method_list_t *instanceMethods;//实例方法列表 struct method_list_t *classMethods;//类方法列表 struct protocol_list_t *protocols;//协议列表 struct property_list_t *instanceProperties;//实例属性的列表，没有实例变量的列表。 // Fields below this point are not always present on disk. struct property_list_t *_classProperties; method_list_t *methodsForMeta(bool isMeta) &#123; if (isMeta) return classMethods; else return instanceMethods; &#125; property_list_t *propertiesForMeta(bool isMeta, struct header_info *hi);&#125;; 加载调用栈 关联对象添加成员成员变量（关联对象）实际效果 扩展用处 声明私有属性 声明私有方法 声明私有成员变量 特点 编译时决议 只以声明的形式存在，多少情况下寄生于宿主的 .m 中 不能为系统类添加扩展 代理是代理模式可以定义方法也可以定义属性 通知 是使用观察者模式来实现跨层传递消息 传递方式为一对多 通知机制的自实现 KVO KVO 是 key-value observing 缩写 KVO 是 Objective-C对观察者模式的实现 KVO 使用了isa混写(isa-swizzling)来实现 特点 使用setter 方法改变值kvo 才能生效 使用setValue:forkey:改变值KVO 会生效 成员变量直接修改必须手动添加KVO 才生效 KVC - (nullable id)valueForKey:(NSString *)key; - (void)setValue:(nullable id)value forKey:(NSString *)key; key 是没有任何限制的，如果知道某各类的私有变量名称是可以直接获取变量和设置变量的值会破坏面向对象编程思想的 Get 方法调用流程 Accessor Method如果 [obj valueForkey:@&quot;key&quot;] 访问方法存在的规则 getKey 有属性名称 key isKey 如果实现isKey 的get方法 Instance Var _key _iskey iskey iskey set 方法调用流程 属性关键字关键字分类 读写权限 readonly readwrite 原子性 atomic nonatomic 引用计数 retain/strong assign/unsafe_unretained week copy atomic 修饰数组，赋值获取，可以保证线程安全 添加对象，移除对象，不能保证线程安全assign 修饰基本数据类型 修饰对象类型，不改变引用计数， 会产生悬垂指针，对象释放后悔指向原对象地址week 不改变对象的引用计数 所指对象在释放后悔自动设置为nilcopy 可变对象copy后变成不可变对象 不可变对象copy后还是不可变对象 assign和week区别1 assgin 可以修改对象和基本数据类型，week 只能修饰对象2 assgin 释放后指针指向原对象地址]]></content>
      <categories>
        <category>Objective c</category>
      </categories>
      <tags>
        <tag>ios</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[二叉树排序]]></title>
    <url>%2F2019%2F01%2F03%2F%E4%BA%8C%E5%8F%89%E6%A0%91%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[根据前序、中序、后序遍历还原二叉树遍历二叉树的规律 前序遍历：先访问当前节点，再访问当前节点的左子树，最后访问当前节点的右子树。对于二叉树，深度遍历与此同。规律：根在前；子树在根后且左子树比右子树靠前，且第一个就是根节点； 中序遍历：先访问当前节点的左子树，然后访问当前节点，最后是当前节点的右子树，二叉树，中序遍历会得到数据升序效果。规律：根在中；左子树在跟左边，右子树在根右边，左边部分是根结点的左子树的中序遍历序列，右边部分是根结点的右子树的中序遍历序列 ； 后序遍历：先访问当前节点的左子树，然后是当前节点的又子树，最后是当前节点。规律：根在后；子树在根前且左子树比右子树靠前，且最后一个节点是根节点。 前序+中序 根据前序序列的第一个元素建立根结点； 在中序序列中找到该元素，确定根结点的左右子树的中序序列； 在前序序列中确定左右子树的前序序列； 由左子树的前序序列和中序序列建立左子树； 由右子树的前序序列和中序序列建立右子树。 如：已知一棵二叉树的先序遍历序列和中序遍历序列分别是abdgcefh、dgbaechf，求二叉树及后序遍历序列。 先序：abdgcefh---&gt;a bdg cefh 中序：dgbaechf----&gt;dgb a echf 得出结论：a是树根，a有左子树和右子树，左子树有bdg结点，右子树有cefh结点。 先序：bdg---&gt;b dg 中序：dgb ---&gt;dg b 得出结论：b是左子树的根结点，b无右子树，有左子树。 先序：dg----&gt;d g 中序：dg-----&gt;dg 得出结论：d是b左子树的根节点,d无左子树，g是d的右子树 然后对于a 的右子树类似可以推出 后序遍历：gdbehfca 后序+中序：已知一棵二叉树的后序序列和中序序列，构造该二叉树的过程如下： 根据后序序列的最后一个元素建立根结点； 在中序序列中找到该元素，确定根结点的左右子树的中序序列； 在后序序列中确定左右子树的后序序列； 由左子树的后序序列和中序序列建立左子树； 由右子树的后序序列和中序序列建立右子树 如还是上面题目：如：已知一棵二叉树的后序遍历序列和中序遍历序列分别是gdbehfca、dgbaechf，求二叉树 后序：gdbehfca----&gt;gdb ehfc a 中序：dgbaechf-----&gt;dgb a echf 得出结论：a是树根，a有左子树和右子树，左子树有bdg结点，右子树有cefh结点。 后序：gdb----&gt;gd b 中序：dgb-----&gt;dg b 得出结论：b是a左子树的根节点，无右子树，有左子树dg。 后序：gd----&gt;g d 中序：dg-----&gt;d g 得出结论：d是b的左子树根节点，g是d的右子树。 然后对于a 的右子树类似可以推出。然后还原。 前序+后序前序和后序在本质上都是将父节点与子结点进行分离，但并没有指明左子树和右子树的能力，因此得到这两个序列只能明确父子关系，而不能确定一个二叉树。 故此法无。不能唯一确定一个二叉树。 原文：https://blog.csdn.net/yanerhao/article/details/45175943]]></content>
  </entry>
  <entry>
    <title><![CDATA[RunTime 相关结构体]]></title>
    <url>%2F2018%2F11%2F13%2FRunTime-%E7%9B%B8%E5%85%B3%E7%BB%93%E6%9E%84%E4%BD%93%2F</url>
    <content type="text"><![CDATA[RunTime 相关结构体Runtime 功能介绍 objc_object objc_class Class 描述 objc_class 的结构体 类对象(继承自objc_object) superClass 指向Class,如果类对象指向父类。cache 代表方法缓存。bits 包含该类变量、属性、方法 isa_t C++ 中的共用体,在32（64）位是32（64）个 0 或者1数字 分成指针型和非指针型的目的是，实际只有30-40位就可以寻找到 class地址，多出来的部分其他的内容，达到节省内存的目的 指向 对象，指向 类对象 类对象，指向 元类对象（MetaClass） 方法查找：对象的方法通过对象所对应的类对象进行方法查找类对象方法通过所对应元类对象进行方法查找 cache_t用于快速查找方法执行函数提高方法调用的速度，和传递的书读是可以增量扩展的哈希表结构是局部性原理最佳应用 局部性原理：把调用率方法放入缓存中，下次调用的命中率会高一些 12345struct cache_t &#123; struct bucket_t *_buckets; mask_t _mask; mask_t _occupied; &#125; 12345struct bucket_t &#123;private: cache_key_t _key; IMP _imp;&#125;; class_data_bits_t class_data_bits_t 主要对 class_rw_t的封装 class_rw_t代表了类相关的读写信息、对class_ro_t的封装 class_ro_t 代表了类的只读信息class_rw_tclass_rw_t 包含类及其分类中的协议、属性、方法 class_ro_t name 类名 ivars 声明或定义的类的成员变量 properties 类的属性 protocols 写的遵从的协议 methodList 方法列表 class_ro_t 包含该类中的协议、属性、方法。 method_t12345struct method_t &#123; SEL name; const char *types; IMP imp;&#125;; name 方法名称 types 方法的返回值和参数的组合 imp 无类型的函数指针，指向的是函数体 Type Encodings method_t-&gt;types]]></content>
      <categories>
        <category>Runtime</category>
      </categories>
      <tags>
        <tag>IOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IOS UI 总结]]></title>
    <url>%2F2018%2F10%2F12%2FIOS-UI-%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[UI 视图屏幕的显示原理CRT 的电子枪按照屏幕最上方，从左到右，一行行的进行扫描。显示器会用硬件时钟产生的一系列信号，把显示器的显示过程和系统的显示控制器同步。CRT换到下一行的时候，准备扫描的时候，显示器会发出一个水平同步信号horizonal synchronization），简称 HSync。 当一帧全部扫描完成后，CRT回复到初始状态时候，会发出一个垂直同步信号（vertical synchronization）简称VSync, 显示器通常会一VSync的频率进行刷新 通常来说CPU 和GPU 是一上面的方式协同工作。 CPU 计算好显示内容，提交给GPU GPU 渲染完成后将结果放入缓存区 视频控制器会按照VSync的信号逐行读取帧缓冲区的数据，经过可能的数据模型转换 显示到屏幕上 卡顿产生的原因 VSync信号到来之后，系统图形服务会通过CADisplayLink 等机制通过APP APP 主线程开始通过CPU计算显示内容，比如视频的创建，布局计算，图片解码等。 CPU 计算好的的结果提交给GPU。 GPU 进行变换、合成、渲染。 GPU 提交到帧缓存区 VSync 再次到来后显示 如果两个VSync 的时间段内CPU和GPU没有全部处理完成提交。当前这一帧会被忽略，继续等待下一帧，这次屏幕显示会保留上次的显示不变。这就是界面卡顿的原因。 CPU 和 GPU 不论哪个阻碍了显示流程，都会造成掉帧现象。所以开发时，也需要分别对 CPU 和 GPU 压力进行评估和优化。 CPU 资源消耗原因和优化对象创建会分配内存，调整属性，还有文件的读写操作等操作，比较消化CPU资源。 对象创建 尽量使用轻量级别的对象，比如CALayer比UIVIew 轻量，不需要点击事件，用CAlayer 比较合适 尽量推迟对象创建时间。并把对象创业分配到多个任务中（比如懒加载） 对象最好可以服用，服用的代价比创建，释放对象消耗小。对象尽量放在一个缓冲池中服用。 对象调整 对象调经常消耗CPU资源，CALayer内部没有属性，在调用相关属性时,是生成一个临时方法,调用结束后再把值存到 CALayer的一个字典中,所以在调整 UIView的相关属性时, UIView和 CALayer 之间会产生一系列的通知和代理.所以在优化性能时,应该尽量避免调整视图层次 添加和移除视图. 对象销毁 对象的销毁相对消耗的资源较少,通常当容器类持有大量对象时,其造成的消耗也是非常明显的,所以应当将消耗过程放到后台线程执行. 布局计算 布局计算也是常见的CPU 消耗.在页面内布局非常复杂时,最好能提前在后台计算好布局 图片的size最好刚好跟UIImageView的size保持一致 文本渲染 大量文本显示的时候，用TextKit或CoreText 对文本异步绘制，能直接过去文本宽高信息，也能减少多次绘制。CoreText 对象占用内存较少，可以缓存下来以备稍后多次渲染。 控制一下线程的最大并发数量 尽量把耗时的操作放到子线程 图片的解码 UIImage 或者 CGImageSource 的那几个方法去创建图片的时候，图片数据并不会立刻解码。图片设置到 UIImageView 或者 CALayer.contents 中去，并且 CALayer 被提交到 CPU 前，CGImage 中的数据才会得到解码，这一步是发生在主线程的，并且不可避免。如果想绕开这个机制，常见的做法就是在后台线程先把图片绘制到 CGBitmapContent 中，然后从 Bitmap 直接创建图片。 图片的绘制 图片的绘制通常是指那些以 CG 开头的方法把图像放到画布中，常见的地方是 [UIView drawRect:] 。由于 CoreGraphic 方法通常都是线程安全的，所以图像的绘制可以很容易的放到后台线程去执行，一个简单的异步绘制的过程大概如下1234567891011- (void) display &#123; dispatch_async(backgroundQueue, ^&#123; CGContextRef ctx = CGBitmapContextCreate(...); // draw in context... CGImageRef img = CGBitmapContextCreateImage(ctx); CFRelease(ctx); dispatch_async(mainQueue, ^&#123; layer.contents = img; &#125;); &#125;); &#125; GPU 资源消耗原因和优化 GPU :接收提交的纹理（Texture）和顶点描述（三角形），应用变换（transform）、混合并渲染，然后输出到屏幕上。所有的 bitmap 包括图片、文本最终都要由内存提交到显存,绑定为 GPU Texture .无论是提交到显存的过程,还是GPU调整和渲染 Texture的过程,都要消耗不少的 GPU 资源. 纹理的渲染 所有的bitmap，view ，栅格化都要提交GPU，绑定GPU Texture，提交过程还是绑定过程都要消耗GPU资源。当在短时间内处理大量图片时候，CPU 占用率低，GPU占用率高。所以尽可能的多张照片合成一张照片。 处理大图片，CPU，GPU 消耗都非常大，ios 纹理尺寸上限都是4096×4096。尽量不要让图片和视频超过这个值 视图的混合多个视图重叠后，GPU首先会把他们混合在一起。视图结果如果过于复杂。混合过程也会消耗很多GPU资源。 尽量减少视图数量和层次 不透明的视图里标明 opaque 属性以避免无用的 Alpha 通道合成 也可以把多个视图预先渲染为一张图片来显示 图形的生成 离屏渲染： 处理图层的属性在被指定为未被预和成之前不能直接在屏幕上显示，GPU在当前屏幕以为缓冲区意外新开辟一个缓冲区进行的渲染操作。 离屏渲染的触发 ： CALayer 的 border、圆角、阴影、遮罩（mask），CASharpLayer 的矢量图形显示，通常会触发离屏渲染（offscreen rendering） 离屏渲染避免 可以尝试开启 CALayer.shouldRasterize 属性，但这会把原本离屏渲染的操作转嫁到 CPU 上去 用一张已经绘制好的圆角图片覆盖到原本视图上面来模拟相同的视觉效果 就是把需要显示的图形在后台线程绘制为图片，避免使用圆角、阴影、遮罩等属性 UIView 绘制原理UIView 在调用setNeedsDisplay，系统调用view 对应layer 的setNeedsDisplay，对layer进行标记。VSync（runloop）消息到来的时候，调用 CAlayer 的dispaly 方法，进入真正的绘制流程中。 App 的 主线程Runloop 在启动后会注册对应的 CFRunLoopSource 通过 mach_port 接收传过来的时钟信号通知，随后 Source 的回调会驱动整个 App 的动画与显示。 CALayer的display方法的内部实现,首先会判断layer的delegete是否响应display方法,如果代理不响应就会进入到系统的绘制流程当中,如果响应,实际上就为我们提供了异步绘制的接口,这样就构成了UIView的绘制原理 graph TD A[UIView setNeedDisplay] A-->B[layer setNeedsDisplay] B-->C[CALayer display] C-->D[layer.delegate displayLayer] D-->|YES| E[异步绘制入口] D-->|NO| F[系统绘制流程] E-->G[开始绘制] F-->G[开始绘制] 异步绘制入口 CPU会为layer分配一块内存用来绘制bitmap，叫做backing store 创建指向这块bitmap缓冲区的指针，叫做CGContextRef 通过Quartz2D，绘制bitmap 如果layer实现deleget（也就是 View 的drawRect）.可以通过drawRect方法做一些其他的绘制工作 都有calayer上传backing store graph TD A[CALayer 创建 backing store CGContextRef] A-->B[layer 是否实现代理] B-->|NO|C[CAlayer drawInContext] B-->|YES|D[layer.delegate drawLayer:inContext:] D-->E[UIView drawRect:] C-->F E-->F[CALayer 上传CGContextRef 到GPU] ##### 异步绘制 如果遵从或者实现了displayLayer方法,我们就可以进入到异步绘制流程当中,在异步绘制的过程当中 * 就由delegete去负责生成bitmap位图 * 设置改bitmap作为layer.content属性的值 graph TD A[main queue] A-->C[AsyncDrawingView setNeedDisplay] C-->D[CALayer display] D-->E[AsyncDrawingView displayLayer] E-->F[Other work] F-->G[CAlayer setContents:] graph LR A[Global queue] B{Other work} Z[Global queue] A-->B B-->C[CGBitmapContextCreate] B-->D[CoreGraphic API] B-->F[CGBitMapContextCreateImage] C-->Z D-->Z F-->Z]]></content>
      <categories>
        <category>UI</category>
      </categories>
      <tags>
        <tag>IOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IOS Block 总结]]></title>
    <url>%2F2018%2F09%2F12%2FIOS-Block-%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[Block block 是c 的运行时代码块。类似c，但是在执行过程中，还可以动态绑定堆栈里面的数据。可以对变量使用和修改。c 语言不支持带有自动变量（局部变量）的匿名函数，block 是支持带有自动变量（局部变量）的匿名函数 匿名函数: 1234int func(int count);int (*funcPtr)(int) = &amp;func;int result = (*funcPtr)(10); block 引用外部变量block 捕获外部局部变量123456int val = 10; void (^block)(void) = ^&#123; printf(&quot;val=%d\n&quot;,val);&#125;; val = 2; block(); 上面这段代码，输出值是：val = 10，而不是2。 123456789int main(int argc, char * argv[]) &#123; int val = 10; int va2l = 10; void (*blk)(void) = ((void (*)())&amp;__main_block_impl_0((void *)__main_block_func_0, &amp;__main_block_desc_0_DATA, val, va2l)); val = 2; ((void (*)(__block_impl *))((__block_impl *)blk)-&gt;FuncPtr)((__block_impl *)blk); return 1;&#125; 12345static void __main_block_func_0(struct __main_block_impl_0 *__cself) &#123; int val = __cself-&gt;val; // bound by copy printf(&quot;%d&quot;,val);&#125; int val = __cself-&gt;val; // bound by copy新建了对象后对值进行了拷贝,内部不能对外部的变量修改，不然编译报错: Variable is not assignable (missing __block type specifier) block 捕获外部全局变量1234567891011121314151617181920212223242526@implementation TestClass- (instancetype)init&#123; self = [super init]; if (self) &#123; testVal = 88; &#125; return self;&#125;- (void)testfun&#123; void (^blk)(void) = ^&#123; NSLog(@&quot;%d --&gt; 1&quot;,testVal); testVal = 99; NSLog(@&quot;%d --&gt; 2&quot;,testVal); &#125;; testVal = 66; blk(); NSLog(@&quot;%d --&gt; 1&quot;,testVal);&#125;- (void)dealloc&#123; NSLog(@&quot;%@&quot;,@&quot;dealloc&quot;);&#125;@end 上面这段代码，输出值是：66 –&gt; 1 99 –&gt; 2 12345678910111213141516171819202122static instancetype _I_TestClass_init(TestClass * self, SEL _cmd) &#123; self = ((TestClass *(*)(__rw_objc_super *, SEL))(void *)objc_msgSendSuper)((__rw_objc_super)&#123;(id)self, (id)class_getSuperclass(objc_getClass(&quot;TestClass&quot;))&#125;, sel_registerName(&quot;init&quot;)); if (self) &#123; (*(int *)((char *)self + OBJC_IVAR_$_TestClass$testVal)) = 88; &#125; return self;&#125;static void __TestClass__testfun_block_func_0(struct __TestClass__testfun_block_impl_0 *__cself) &#123; TestClass *self = __cself-&gt;self; // bound by copy NSLog((NSString *)&amp;__NSConstantStringImpl__var_folders_gx_vvhdc9796yl0wh42wfmx849c0000gn_T_main_c00845_mii_0,(*(int *)((char *)self + OBJC_IVAR_$_TestClass$testVal))); (*(int *)((char *)self + OBJC_IVAR_$_TestClass$testVal)) = 99; NSLog((NSString *)&amp;__NSConstantStringImpl__var_folders_gx_vvhdc9796yl0wh42wfmx849c0000gn_T_main_c00845_mii_1,(*(int *)((char *)self + OBJC_IVAR_$_TestClass$testVal))); &#125;static void _I_TestClass_testfun(TestClass * self, SEL _cmd) &#123; void (*blk)(void) = ((void (*)())&amp;__TestClass__testfun_block_impl_0((void *)__TestClass__testfun_block_func_0, &amp;__TestClass__testfun_block_desc_0_DATA, self, 570425344)); (*(int *)((char *)self + OBJC_IVAR_$_TestClass$testVal)) = 66; ((void (*)(__block_impl *))((__block_impl *)blk)-&gt;FuncPtr)((__block_impl *)blk);&#125; 在block 内部和外部修改变量值都是通过self 来修改。没有创建新的变量 block 捕获静态变量12345678910111213static int testVal = 2;@implementation TestClass- (void)testfun&#123; void (^blk)(void) = ^&#123; testVal = 99; NSLog(@&quot;%d --&gt; 1&quot;,testVal); &#125;; blk();&#125;@end 上面这段代码，输出值是：99 –&gt; 1 1234static void __TestClass__testfun_block_func_0(struct __TestClass__testfun_block_impl_0 *__cself) &#123; testVal = 99; printf(&quot;%d&quot;,testVal);&#125; 可以修改静态变量的值：静态变量属于类的，不是某一个变量。由于block内部不用调用self指针。所以block可以调用。 全局block 访问全局变量 – 循环引用12345678910111213141516171819202122232425262728@interface TestClass : NSObject&#123;&#125;@property(nonatomic,assign) int testVal;@property(nonatomic,strong) void(^testBlock)();- (void)testfun;@end@implementation TestClass- (instancetype)init&#123; self = [super init]; if (self) &#123; self.testVal = 99; [self setTestBlock:^&#123; int tempValue = _testVal; printf(&quot;%d&quot;,tempValue) ; &#125;] ; self.testVal = 88; &#125; return self;&#125;- (void)testfun&#123; self.testBlock();&#125;- (void)dealloc&#123; NSLog(@&quot;%@&quot;,@&quot;dealloc&quot;);&#125;@end 上面这段代码，输出值是：88,没有执行 dealloc，循环引用 // code 1123456789static instancetype _I_TestClass_init(TestClass * self, SEL _cmd) &#123; self = ((TestClass *(*)(__rw_objc_super *, SEL))(void *)objc_msgSendSuper)((__rw_objc_super)&#123;(id)self, (id)class_getSuperclass(objc_getClass(&quot;TestClass&quot;))&#125;, sel_registerName(&quot;init&quot;)); if (self) &#123; ((void (*)(id, SEL, int))(void *)objc_msgSend)((id)self, sel_registerName(&quot;setTestVal:&quot;), 99); ((void (*)(id, SEL, void (*)()))(void *)objc_msgSend)((id)self, sel_registerName(&quot;setTestBlock:&quot;), ((void (*)())&amp;__TestClass__init_block_impl_0((void *)__TestClass__init_block_func_0, &amp;__TestClass__init_block_desc_0_DATA, self, 570425344))) ; ((void (*)(id, SEL, int))(void *)objc_msgSend)((id)self, sel_registerName(&quot;setTestVal:&quot;), 88); &#125; return self;&#125; 123456789101112// code 2struct __TestClass__init_block_impl_0 &#123; struct __block_impl impl; struct __TestClass__init_block_desc_0* Desc; TestClass *self; __TestClass__init_block_impl_0(void *fp, struct __TestClass__init_block_desc_0 *desc, TestClass *_self, int flags=0) : self(_self) &#123; impl.isa = &amp;_NSConcreteStackBlock; impl.Flags = flags; impl.FuncPtr = fp; Desc = desc; &#125;&#125;; 123456// code 3static void __TestClass__init_block_func_0(struct __TestClass__init_block_impl_0 *__cself) &#123; TestClass *self = __cself-&gt;self; // bound by copy int tempValue = (*(int *)((char *)self + OBJC_IVAR_$_TestClass$_testVal)); printf(&quot;%d&quot;,tempValue) ;&#125; TestBlock 是全局变量，__TestClass__init_block_impl_0 对self 有引用（只要是全局变量都会使用self 来获取），self retainCount + 1，TestClass 释放的时候 retainCount -1 ,在释放 block 对象的时候，block 有self 的强指针，导致无法释放 block 存放区域存放的是 NSConcreteStackBlock123456789- (void)testfun&#123; int testVal = 10 ; void (^blk)(void) = ^&#123; printf(&quot;%d&quot;,testVal); &#125;; testVal = 2; blk();&#125; 1234567891011struct __TestClass__testfun_block_impl_0 &#123; struct __block_impl impl; struct __TestClass__testfun_block_desc_0* Desc; int testVal; __TestClass__testfun_block_impl_0(void *fp, struct __TestClass__testfun_block_desc_0 *desc, int _testVal, int flags=0) : testVal(_testVal) &#123; impl.isa = &amp;_NSConcreteStackBlock; impl.Flags = flags; impl.FuncPtr = fp; Desc = desc; &#125;&#125;; 存放的是 NSConcreteStackBlock1234567- (void)testfun&#123; void (^blk)(void) = ^&#123; int testVal = 10 ; printf(&quot;%d&quot;,testVal); &#125;; blk();&#125; 12345678910struct __TestClass__testfun_block_impl_0 &#123; struct __block_impl impl; struct __TestClass__testfun_block_desc_0* Desc; __TestClass__testfun_block_impl_0(void *fp, struct __TestClass__testfun_block_desc_0 *desc, int flags=0) &#123; impl.isa = &amp;_NSConcreteStackBlock; impl.Flags = flags; impl.FuncPtr = fp; Desc = desc; &#125;&#125;; NSConcreteStackBlock1234567891011121314151617181920212223242526@interface TestClass : NSObject&#123; int testVal ;&#125;- (void)testfun;@end@implementation TestClass- (instancetype)init&#123; self = [super init]; if (self) &#123; testVal = 10; &#125; return self;&#125;- (void)testfun&#123; void (^blk)(void) = ^&#123; printf(&quot;%d&quot;,self-&gt;testVal); &#125;;// testVal = 2; blk();&#125;- (void)dealloc&#123;&#125;@end 1234567891011struct __TestClass__testfun_block_impl_0 &#123; struct __block_impl impl; struct __TestClass__testfun_block_desc_0* Desc; TestClass *self; __TestClass__testfun_block_impl_0(void *fp, struct __TestClass__testfun_block_desc_0 *desc, TestClass *_self, int flags=0) : self(_self) &#123; impl.isa = &amp;_NSConcreteStackBlock; impl.Flags = flags; impl.FuncPtr = fp; Desc = desc; &#125;&#125;; NSConcreteStackBlock123456789101112131415161718192021222324252627282930@interface TestClass : NSObject&#123; int testVal ;&#125;@property (nonatomic,strong) void (^testBlock)();@end@implementation TestClass- (instancetype)init&#123; self = [super init]; if (self) &#123; testVal = 10; [self setTestBlock:^&#123; &#125;]; &#125; return self;&#125;@endstruct __TestClass__init_block_impl_0 &#123; struct __block_impl impl; struct __TestClass__init_block_desc_0* Desc; __TestClass__init_block_impl_0(void *fp, struct __TestClass__init_block_desc_0 *desc, int flags=0) &#123; impl.isa = &amp;_NSConcreteStackBlock; impl.Flags = flags; impl.FuncPtr = fp; Desc = desc; &#125;&#125;; NSConcreteGlobalBlock123456789101112131415161718void (^blk) () = ^&#123; printf(&quot;Block&quot;);&#125;;- (void)testfun&#123; blk();&#125;struct __blk_block_impl_0 &#123; struct __block_impl impl; struct __blk_block_desc_0* Desc; __blk_block_impl_0(void *fp, struct __blk_block_desc_0 *desc, int flags=0) &#123; impl.isa = &amp;_NSConcreteGlobalBlock; impl.Flags = flags; impl.FuncPtr = fp; Desc = desc; &#125;&#125;;]]></content>
      <categories>
        <category>Block</category>
      </categories>
      <tags>
        <tag>IOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTTP Agreement]]></title>
    <url>%2F2018%2F06%2F09%2FHTTP-Agreement%2F</url>
    <content type="text"><![CDATA[HTTP协议详解HTTP协议，即超文本传输协议(Hypertext transfer protocol)。是一种详细规定了浏览器和万维网(WWW = World Wide Web)服务器之间互相通信的规则，通过因特网传送万维网文档的数据传送协议。 HTTP是一个应用层协议，由请求和响应构成，是一个标准的客户端服务器模型。HTTP是一个无状态的协议。 所有的传输都是通过TCP/IP进行的。 HTTP协议作为TCP/IP模型中应用层的协议 HTTP协议通常承载于TCP协议之上，有时也承载于TLS或SSL协议层之上（https） HTTP默认的端口号为80，HTTPS的端口号为443。 特点 HTTP 永远是客户端发情请求，服务端回送响应。 支持客户/服务器模式。支持基本认证和安全认证。 简单快速：客户向服务器请求服务时，只需传送请求方法和路径。请求方法常用的有GET、HEAD、POST。每种方法规定了客户与服务器联系的类型不同。由于HTTP协议简单，使得HTTP服务器的程序规模小，因而通信速度很快。 灵活：HTTP允许传输任意类型的数据对象。正在传输的类型由Content-Type加以标记。 HTTP 1.1使用持续连接：不必为每个web对象创建一个新的连接，一个连接可以传送多个对象，采用这种方式可以节省传输时间。 无状态：HTTP协议是无状态协议。无状态是指协议对于事务处理没有记忆能力。缺少状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能导致每次连接传送的数据量增大。 无状态协议协议的状态是指下一次传输可以“记住”这次传输信息的能力。http是不会为了下一次连接而维护这次连接所传输的信息,为了保证服务器内存。 比如客户获得一张网页之后关闭浏览器，然后再一次启动浏览器，再登陆该网站，但是服务器并不知道客户关闭了一次浏览器 无状态和Connection:keep-alive区别 HTTP/1.1起，默认都开启了Keep-Alive，保持连接特性. 网页打开完成后，客户端和服务器之间用于传输HTTP数据的TCP连接不会关闭，如果客户端再次访问这个服务器上的网页，会继续使用这一条已经建立的连接。 Keep-Alive不会永久保持连接，它有一个保持时间，可以在不同的服务器软件（如Apache）中设定这个时间。 工作流程HTTP是基于传输层的TCP协议，而TCP是一个端到端的面向连接的协议。 简要流程以下是 HTTP 请求/响应的步骤： 1、客户端连接到Web服务器一个HTTP客户端，通常是浏览器，与Web服务器的HTTP端口（默认为80）建立一个TCP套接字连接。例如，http://www.oakcms.cn2、发送HTTP请求通过TCP套接字，客户端向Web服务器发送一个文本的请求报文，一个请求报文由请求行、请求头部、空行和请求数据4部分组成。3、服务器接受请求并返回HTTP响应Web服务器解析请求，定位请求资源。服务器将资源复本写到TCP套接字，由客户端读取。一个响应由状态行、响应头部、空行和响应数据4部分组成。4、释放连接TCP连接若connection 模式为close，则服务器主动关闭TCP连接，客户端被动关闭连接，释放TCP连接;若connection 模式为keepalive，则该连接会保持一段时间，在该时间内可以继续接收请求;5、客户端解析内容 建立TCP连接 户端浏览器与服务器的交互过程：1、 No1：浏览器向服务器（发出连接请求。此为TCP三次握手第一步，此时从图中可以看出，为SYN，seq:X （x=0）；2、 No2：服务器回应了浏览器的请求，并要求确认，此时为：SYN，ACK，此时seq：y（y为0），ACK：x+1（为1）。此为三次握手的第二步；3、 No3：浏览器回应了服务器（115.239.210.36）的确认，连接成功。为：ACK，此时seq：x+1（为1），ACK：y+1（为1）。此为三次握手的第三步；4、 No4：客户端发出HTTP请求；5、 No5：服务器确认；6、 No6：服务器发送数据；7、 No7：客户端确认； 请求头域URL 详情URI一般由三部组成：①协议(或称为服务方式)②存有该资源的主机IP地址(有时也包括端口号)③主机资源的具体地址。如目录和文件名等 HTTP之请求消息Request 12345GET /books HTTP/1.1Host: www.wrox.comUser-Agent: Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US; rv:1.7.6)Gecko/20050225 Firefox/1.0.1Connection: Keep-Alive 请求行用来说明请求类型,要访问的资源以及所使用的HTTP版本.GET说明请求类型为GET,/books为要访问的资源，该行的最后一部分说明使用的是HTTP1.1版本。 请求头部紧接着请求行（即第一行）之后的部分，用来说明服务器要使用的附加信息 HOST 将指出请求的域名或IP 地址。 User-Agent,服务器端和客户端脚本都能访问它，它是浏览器类型检测逻辑的重要基础.该信息由你的浏览器来定义,并且在每个请求中自动发送 header 解释 示例 Accept 指定客户端能够接收的内容类型 Accept: text/plain, text/html Accept-Charset 浏览器可以接受的字符编码集。 Accept-Charset: iso-8859-5 Accept-Encoding 指定浏览器可以支持的web服务器返回内容压缩编码类型。 Accept-Encoding: compress, gzip Accept-Language 浏览器可接受的语言 Accept-Language: en,zh Accept-Ranges 可以请求网页实体的一个或者多个子范围字段 Accept-Ranges: bytes Authorization HTTP授权的授权证书 Authorization: Basic QWxhZGRpbjpvcGVuIHNlc2FtZQ== Cache-Control 指定请求和响应遵循的缓存机制 Cache-Control: no-cache Connection 表示是否需要持久连接。（HTTP 1.1默认进行持久连接） Connection: close Cookie HTTP请求发送时，会把保存在该请求域名下的所有cookie值一起发送给web服务器。 Cookie: $Version=1; Skin=new; Content-Length 请求的内容长度 Content-Length: 348 Content-Type 请求的与实体对应的MIME信息 Content-Type: application/x-www-form-urlencoded Date 请求发送的日期和时间 Date: Tue, 15 Nov 2010 08:12:31 GMT Expect 请求的特定的服务器行为 Expect: 100-continue From 发出请求的用户的Email From: user@email.com Host 指定请求的服务器的域名和端口号 Host: www.zcmhi.com If-Match 只有请求内容与实体相匹配才有效 If-Match: “737060cd8c284d8af7ad3082f209582d” If-Modified-Since 如果请求的部分在指定时间之后被修改则请求成功，未被修改则返回304代码 If-Modified-Since: Sat, 29 Oct 2010 19:43:31 GMT If-None-Match 如果内容未改变返回304代码，参数为服务器先前发送的Etag，与服务器回应的Etag比较判断是否改变 If-None-Match: Referer“737060cd8c284d8af7ad3082f209582d” If-Range 如果实体未改变，服务器发送客户端丢失的部分，否则发送整个实体。参数也为Etag If-Range: “737060cd8c284d8af7ad3082f209582d” If-Unmodified-Since 只在实体在指定时间之后未被修改才请求成功 If-Unmodified-Since: Sat, 29 Oct 2010 19:43:31 GMT Max-Forwards 限制信息通过代理和网关传送的时间 Max-Forwards: 10 Pragma 用来包含实现特定的指令 Pragma: no-cache Proxy-Authorization 连接到代理的授权证书 Proxy-Authorization: Basic QWxhZGRpbjpvcGVuIHNlc2FtZQ== Range 只请求实体的一部分，指定范围 Range: bytes=500-999 Referer 先前网页的地址，当前请求网页紧随其后,即来路 Referer: http://www.zcmhi.com/archives/71.html TE 客户端愿意接受的传输编码，并通知服务器接受接受尾加头信息 TE: trailers,deflate;q=0.5 Upgrade 向服务器指定某种传输协议以便服务器进行转换（如果支持） Upgrade: HTTP/2.0, SHTTP/1.3, IRC/6.9, RTA/x11 User-Agent User-Agent的内容包含发出请求的用户信息 User-Agent: Mozilla/5.0 (Linux; X11) Via 通知中间网关或代理服务器地址，通信协议 Via: 1.0 fred, 1.1 nowhere.com (Apache/1.1) Warning 关于消息实体的警告信息 Warn: 199 Miscellaneous warning 通用的信息性首部:Connection,Date,MIME-Version 空行请求头部后面的空行是必须的，即使第四部分的请求数据为空，也必须有空行。 主体请求数据也叫主体，可以添加任意的其他数据。 12345678POST / HTTP1.1Host:www.wrox.comUser-Agent:Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; SV1; .NET CLR 2.0.50727; .NET CLR 3.0.04506.648; .NET CLR 3.5.21022)Content-Type:application/x-www-form-urlencodedContent-Length:40Connection: Keep-Alivename=Professional%20Ajax&amp;publisher=Wiley 第一部分：请求行，第一行明了是post请求，以及http1.1版本。第二部分：请求头部，第二行至第六行。第三部分：空行，第七行的空行。第四部分：请求数据，第八行。 请求方法HTTP/1.1协议中共定义了八种方法（有时也叫“动作”）来表明Request-URI指定的资源的不同操作方式： OPTIONS- 返回服务器针对特定资源所支持的HTTP请求方法。也可以利用向Web服务器发送’*’ 的请求来测试服务器的功能性。 HEAD- 向服务器索要与GET请求相一致的响应，只不过响应体将不会被返回。这一方法可以在不必传输整个响应内容的情况下，就可以获取包含在响应消息头中的元信息。该方法常用于测试超链接的有效性，是否可以访问，以及最近是否更新。 GET- 向特定的资源发出请求。注意：GET方法不应当被用于产生“副作用”的操作中，例如在web app.中。其中一个原因是GET可能会被网络蜘蛛等随意访问。 POST- 向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。POST请求可能会导致新的资源的建立和/或已有资源的修改。 PUT- 向指定资源位置上传其最新内容。 DELETE- 请求服务器删除Request-URI所标识的资源。 TRACE- 回显服务器收到的请求，主要用于测试或诊断。 CONNECT- HTTP/1.1协议中预留给能够将连接改为管道方式的代理服务器。 PATCH- 用来将局部修改应用于某一资源，添加于规范RFC5789。 响应消息客户端向服务器发送一个请求，服务器以一个状态行作为响应. 响应的内容包括 消息协议的版本 成功或者错误编码 服务器信息 实体元信息 实体内容 状态行由HTTP协议版本号， 状态码， 状态消息 三部分组成。（HTTP/1.1）表明HTTP版本为1.1版本，状态码为200，状态消息为（ok）消息报头用来说明客户端要使用的一些附加信息.第二行和第三行为消息报头.Date:生成响应的日期和时间；Content-Type:指定了MIME类型的HTML(text/html),编码类型是UTF-8 空行消息报头后面的空行是必须的 响应正文空行后面的部分为响应正文。 HTTP之状态码状态代码有三位数字组成，第一个数字定义了响应的类别，共分五种类别: 1xx：指示信息–表示请求已接收，继续处理 2xx：成功–表示请求已被成功接收、理解、接受 3xx：重定向–要完成请求必须进行更进一步的操作 4xx：客户端错误–请求有语法错误或请求无法实现 5xx：服务器端错误–服务器未能实现合法的请求 1234567200 OK //客户端请求成功400 Bad Request //客户端请求有语法错误，不能被服务器所理解401 Unauthorized //请求未经授权，这个状态代码必须和WWW-Authenticate报头域一起使用 403 Forbidden //服务器收到请求，但是拒绝提供服务404 Not Found //请求资源不存在，eg：输入了错误的URL500 Internal Server Error //服务器发生不可预期的错误503 Server Unavailable //服务器当前不能处理客户端的请求，一段时间后可能恢复正常]]></content>
      <categories>
        <category>网络</category>
      </categories>
      <tags>
        <tag>http</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Socket 网络编程]]></title>
    <url>%2F2018%2F06%2F06%2FSocket%2F</url>
    <content type="text"><![CDATA[Socket 网络编程网络是信息的传输、接受、共享的虚拟平台，通过点、面、体联系实现资源共享。 网络编程是对信息的接收，通过调用相应的api，利用传输通道进行数据交换的过程。设计：网络模型、套接字、数据包。 网络模型客户端传输数据-&gt;表示层-&gt;会话层-&gt;传输层-&gt;网络层-&gt;数据链路层-&gt;物理层接收相反 表示层：把应用的数据表示成数据层对应的数据（比如 字符串转换成byte 数据） 会话层：把不同机器进行会话的管理 传输层：接收上一层的数据。必要的时候把数据分割并将数据交给网络层。保证数据段的有效性（可以有效的把数据传到对面） 网络层: 控制子网的运行（比如路由选择） 数据链路层： 物理的地址寻找，将原始的byte流转换成逻辑的传输路线 物理层： 电信号的传输，原始的byte流传输 功能分类 基础层： 物理层、数据链路层、网络层 传输层：TCP、UDP协议层，Socket 高级层：会话层、表示层、应用层 网络模型对应关系 SocketSocket含义 IP 和 端口地址的结合协议 （RFC 793） 地址和端口的描述协议 TCP/IP 写的总称，网络api 的集合实现 涵盖了： Stream Socket/Datagram Socket (TCP/UDP) Socket 作用和组成传输中用于唯一表示两个端点之间的链接端点：包括（IP + Port） Socket 之 TCP一、 TCP 是面向链接的通讯协议二、 通过三次握手建立链接，通讯完成后拆除连接 客户 端发送一个带SYN标志的TCP报文到server。这是三次握手过程中的报文1。 server端回应client的，这是三次握手中的第2个报文。这个报文同一时候带ACK标志和SYN标志。因此它表示对刚才clientSYN报文的回应。同一时候又标志SYN给client，询问client是否准备好进行数据通 讯。 客户必须再次回应服务段一个ACK报文，这是报文段3。 telnet建立连接，断开连接的使用wireshark捕获的packet截图 TCP建立连接的三次握手过程，以及关闭连接的四次握手过程 三、 由于是面向连接所以只能通讯与端到端的。 Socket 之 UDP一、 UDP 是面向无连接的通讯协议二、 UDP 数据包括目的端口号和源端口号信息三、 通讯不需要连接，所以可以实现广播发送，不局限于端到端。 CS模型（client-server application）进程通讯的主要模型。（客户端和服务器交互的模型） 常见的 FTP SMTP HTTP]]></content>
      <categories>
        <category>Socket</category>
      </categories>
      <tags>
        <tag>Socket</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式]]></title>
    <url>%2F2018%2F01%2F11%2Fruntime%2F</url>
    <content type="text"><![CDATA[设计原则单一职责原则:一个类只承担一个职责 开闭原则:对软件实体的改动，最好用扩展而非修改的方式。类、模块、函数可以扩展，不要去修改。 里氏替换原则:父类的功能都可以用子类替代，不会影响。子类可以扩展父类方法，不要复写父类的方法 接口隔离原则:接口中含有不必要的方法，拆分成更小和更具体接口。 依赖倒置原则：高层模块，低层模块，细节都应该依赖抽象 模块间的依赖通过抽象发生，实现类之间不发生直接的依赖关系，其依赖关系是通过接口或抽象类产生的。 接口或抽象类不依赖实现类 实现类依赖接口或抽象类 项目中使用 每个类尽量都有接口或者抽象类，或者抽象类和接口两都具备 变量的表面类型尽量是接口或者抽象类任何类都不应该从具体类派生尽量不要覆写基类的方法 如果基类是一个抽象类，而这个方法已经实现了，子类尽量不要覆写。类间依赖的是抽象，覆写了抽象方法，对依赖的稳定性会有一定的影响。 结合里氏替换原则使用里氏替换原则：父类出现的地方子类就能出现。结合本章我们得出了一个通俗的规则：接口负责定义public属性和方法，并且声明与其他对象的依赖关系。抽象类负责公共构造部分的实现，实现类准确的实现业务逻辑，同时在适当的时候对父类进行细化。 迪米特法则一个对象应该对其他对象保持最少了解， 就是一个类对自己依赖的类知道的越少越好，也就是对于被依赖的类，向外公开的方法应该尽可能的少。 从被依赖者的角度来说：只暴露应该暴露的方法或者属性，即在编写相关的类的时候确定方法/属性的权限 从依赖者的角度来说，只依赖应该依赖的对象 组合/聚合服用模式在一个新的对象里面使用一些已有的对象，使之成为新对象的一部分；新的对象通过向这些对象的委派达到复用已有功能的目的。它的设计原则是：要尽量使用合成/聚合，尽量不要使用继承。 设计模式创造性模式 处理对象创建的设计模式 两个主导思想 系统使用的具体类封装起来 隐藏具体类的实例创建和结合的方式 工厂模式（Factory Pattern） 定义一个用于创建对象的接口，让子类决定实例化哪一个类。Factory Method 使一个类的实例化延迟到其子类。 当一个类不知道它所必须创建的对象的类的时候。 当一个类希望由它的子类来指定它所创建的对象的时候。 当类将创建对象的职责委托给多个帮助子类中的某一个，并且你希望将哪一个帮助子类是代理者这一信息局部化的时候。 抽象工厂模式（Abstract Factory Pattern） 提供一个接口，用于创建与某些对象相关或依赖于某些对象的类家族，而又不需要指定它们的具体类。通过这种模式可以去除客户代码和来自工厂的具体对象细节之间的耦合关系。 提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类。 一个系统要独立于它的产品的创建、组合和表示时。 一个系统要由多个产品系列中的一个来配置时。 当你要强调一系列相关的产品对象的设计以便进行联合使用时。 当你提供一个产品类库，而只想显示它们的接口而不是实现时。 建造者模式（Builder Pattern） 将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示 当创建复杂对象的算法应该独立于该对象的组成部分以及它们的装配方式时。 当构造过程必须允许被构造的对象有不同的表示时。 原型模式（Prototype Pattern）允许一个对象再创建另外一个可定制的对象，根本无需知道任何如何创建的细节 使用原型实例指定创建对象的种类，并通过复制这个原型创建新的对象。也就是提供一个快速复制对象的快捷方式 深复制，复制的是对象 单例模式（Singleton Pattern）保证一个类仅有一个实例，并提供一个访问它的全局访问点 在只能有一个实例而且客户可以从一个众所周知的访问点访问它时。 结构型模式处理类或对象的组合 适配器模式 （Adapter Pattern）适配器模式把一个类的接口变换成客户端所期待的另一种接口，从而使原本因接口不匹配而无法在一起工作的两个类能够在一起工作。 类的适配器模式类的适配器模式把适配的类的API转换成为目标类的API 对象的适配器模式 与类的适配器模式一样，对象的适配器模式把被适配的类的API转换成为目标类的API，与类的适配器模式不同的是，对象的适配器模式不是使用继承关系连接到Adaptee类，而是使用委派关系连接到Adaptee类。 接口的适配器模式 一个接口中有多个抽象方法。（java）必须实现该接口的所有方法。借助于一个抽象类，该抽象类实现了该接口，实现了所有的方法，只和该抽象类取得联系，继承该抽象类，重写我们需要的方法就行 桥接模式（Bridge Pattern） 桥接模式即将抽象部分与它的实现部分分离开来，使他们都可以独立变化。 桥接模式将继承关系转化成关联关系，它降低了类与类之间的耦合度，减少了系统中类的数量，也减少了代码量。 实现系统可能有多个角度分类，每一种角度都可能变化，那么把这种多角度分类给分离出来让他们独立变化，减少他们之间耦合 组合模式（Composite Pattern）将对象组合成树形结构以表示“部分整体”的层次结构。组合模式使得用户对单个对象和组合对象的使用具有一致性。 装饰模式（Decorator Pattern）这种模式动态地将额外的责任附加到一个对象上。在进行功能扩展时，装饰是子类化之外的一种灵活的备选方法。和子类化一样，采纳装饰模式可以加入新的行为，而又不必修改已有的代码。装饰将需要扩展的类的对象进行包装，实现与该对象相同的接口，并在将任务传递给被包装对象之前或之后加入自己的行为。装饰模式表达了这样的设计原则：类应该接纳扩展，但避免修改 ios Category 外观模式（Facade Pattern）这种模式为子系统中的一组接口提供统一的接口。表观模式定义一个更高级别的接口，通过减少复杂度和隐藏子系统之间的通讯和依赖性，使子系统更加易于使用。 过滤器模式（Filter、Criteria Pattern）过滤器模式（Filter Pattern）或标准模式（Criteria Pattern）是一种设计模式，这种模式允许开发人员使用不同的标准来过滤一组对象，通过逻辑运算以解耦的方式把它们连接起来。这种类型的设计模式属于结构型模式，它结合多个标准来获得单一标准。 享元模式（Flyweight Pattern）享元模式的主要目的是实现对象的共享，即共享池，当系统中对象多的时候可以减少内存的开销，通常与工厂模式一起使用。 适合用享元模式来处理，建一个工厂类，将类似属性作为内部数据，其它的作为外部数据，在方法调用时，当做参数传进来，这样就节省了空间，减少了实例的数量。 代理模式（Proxy Pattern）多一个代理类出来，替原对象进行一些操作 如果已有的方法在使用的时候需要对原有的方法进行改进，此时有两种办法： 1、修改原有的方法来适应。这样违反了“对扩展开放，对修改关闭”的原则。 2、就是采用一个代理类调用原有的方法，且对产生的结果进行控制。这种方法就是代理模式。 行为型模式责任链模式（Chain of Responsibility Pattern）请求创建了一个接收者对象的链。这种模式给予请求的类型，对请求的发送者和接收者进行解耦。这种类型的设计模式属于行为型模式。 通常每个接收者都包含对另一个接收者的引用。如果一个对象不能处理该请求，那么它会把相同的请求传给下一个接收者，依此类推。 命令模式（Command Pattern）将一个请求封装成一个对象，从而让你使用不同的请求把客户端参数化，对请 求排队或者记录请求日志，可以提供命令的撤销和恢复功能。 三个角色： Receiver接受者角色：该角色就是干活的角色，命令传递到这里是应该被执行的 Command命令角色：需要执行的所有命令都在这里声明 Invoker调用者角色：接收到命令，并执行命令 解释器模式（Interpreter Pattern）给定一个语言，定义它的文法表示，并定义一个解释器，这个解释器使用该标识来解释语言中的句子。 三种对象： 语言，即你输入的或者说需要翻译的部分是什么 文法，即你用什么方式、方法翻译改语言。 解释器对象，即该对象包括了多种文法，只需调用该对象进行解释 常见的树的先序遍历、中序遍历、层次遍历、后序遍历等都可以用解释器模式实现。 迭代器模式（Iterator Pattern）迭代器提供了一种顺序访问集合对象中元素的方法，而无需暴漏结构的底层表示和细节。遍历集合中元素的职能从集合本身转移到迭代器对象。迭代器定义了一个用于访问集合元素并记录当前元素的接口。不同的迭代器可以执行不同的策略。 中介者模式（Mediator Pattern）用一个对象来封装一组或者一系列对象的交互方式，使对象间的交互可以在一个中介者对象中处理，从而使各对象耦合松散，而且可以独立的改变它们之间的交互。中介者就好比站在十字路口的交通警察，如果改变十字路口的交通模式，只需要把新的交通策略给交通警察即可，而不是路上的所有车辆，这样才能更好的协调来自不同方向车辆。 备忘录模式（Memento Pattern）在不破坏封闭的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。这样以后就可将该对象恢复到原先保存的状态。 Originator(发起人)：负责创建一个备忘录Memento，用以记录当前时刻自身的内部状态，并可使用备忘录恢复内部状态。Originator可以根据需要决定Memento存储自己的哪些内部状态。 Memento(备忘录)：负责存储Originator对象的内部状态，并可以防止Originator以外的其他对象访问备忘录。备忘录有两个接口：Caretaker只能看到备忘录的窄接口，他只能将备忘录传递给其他对象。Originator却可看到备忘录的宽接口，允许它访问返回到先前状态所需要的所有数据。 Caretaker(管理者):负责备忘录Memento，不能对Memento的内容进行访问或者操作。 观察者模式（Observer Pattern）状态模式（State Pattern）空对象模式（Null Object Pattern）策略模式（Strategy Pattern）模板模式（Template Pattern）访问者模式（Visitor Pattern）]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[消息传递]]></title>
    <url>%2F2017%2F11%2F13%2F%E6%B6%88%E6%81%AF%E4%BC%A0%E9%80%92%2F</url>
    <content type="text"><![CDATA[消息传递 缓存查找给定 目标 SEL,获取目标对应的 bucket_t 中的IMP graph TDA[obj testmethod]A–&gt;C[获取SEL对应的KEY]C–&gt;D[获取bucket_t]缓存调用栈 一、 [obj testmethod] 调用二、 获取方法选择器对应的KEY 12345cache_key_t getKey(SEL sel) &#123; assert(sel); return (cache_key_t)sel;&#125; 三、获取bucket_t 中SEL对应的key12345678910static void cache_fill_nolock(Class cls, SEL sel, IMP imp, id receiver)&#123; ///略。。。 cache_key_t key = getKey(sel); ///略。。。 bucket_t *bucket = cache-&gt;find(key, receiver); if (bucket-&gt;key() == 0) cache-&gt;incrementOccupied(); bucket-&gt;set(key, imp);&#125; cache-&gt;find(key, receiver);1234567891011121314151617bucket_t * cache_t::find(cache_key_t k, id receiver)&#123; assert(k != 0); bucket_t *b = buckets(); mask_t m = mask(); mask_t begin = cache_hash(k, m); mask_t i = begin; do &#123; if (b[i].key() == 0 || b[i].key() == k) &#123; return &amp;b[i]; &#125; &#125; while ((i = cache_next(i, m)) != begin); // hack Class cls = (Class)((uintptr_t)this - offsetof(objc_class, cache)); cache_t::bad_cache(receiver, (SEL)k, cls);&#125; bucket_t 对应的KEY 实际是经过HASH 算法得到 四、通过 bucket_t 获取IMP 调用方法 当前类中查找 对于 已排序好列表，采用 二分查找算法查找方法 对弈 没有排序列表，采用 一般遍历查找对应方法 父类逐级查找]]></content>
      <categories>
        <category>消息传递</category>
      </categories>
      <tags>
        <tag>ios</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Xcode git 忽略无关文件]]></title>
    <url>%2F2017%2F06%2F22%2FXcode-git-%E5%BF%BD%E7%95%A5%E6%97%A0%E5%85%B3%E6%96%87%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[Git版本控制的时候，有很多非代码文件也会被跟踪，比较常见的如一些影藏文件DS_Store、以xcworkspace、xcuserstate、xcuserdata等结尾的状态文件等。为了不把这些文件加入版本控制体系中，我们需要进行以下三步设置，注意，每一步必不可少，也不可交换位置，下文会具体解释原因。 第一步：进入git的代码仓库，执行以下的代码 12git rm --cached *.xcuserstategit rm --cached *.xcuserdata 这两行代码（或者可以有更多，自己修改后缀名即可，这里列出了常见的两种隐藏文件）表示不再追踪以这些后缀结尾的文件，注意这里的文件在执行代码前其实已经被追踪（Tracked），执行完后，将不再被追踪。 修改.gitignore文件 1vim .gitignore 这时候会进入gitignore的文件的编辑界面，如果这个文件已经存在，则可以通过普通的文本编辑器直接进行修改（需要设置显示隐藏文件），复制以下内容进入.gitignore文件。（ignore.io推荐） 1234567891011121314build/*.pbxuser!default.pbxuser*.mode1v3!default.mode1v3*.mode2v3!default.mode2v3*.perspectivev3!default.perspectivev3xcuserdata*.xccheckout*.moved-asideDerivedData*.xcuserstate 按esc键退出编辑，输入：wq保存文件。注意这里的gitignore文件的修改，仅对未追踪（Untracked）的文件生效，所以首先要执行第一步，取消对以上类型文件的追踪。 第三步：提交此处版本修改123git add .git commit -m &quot;igonre files &quot;git push origin master 重启Xcode并且尝试修改一个文件后执行commit，发现那些与代码无关的文件并不会被自动提交了]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>IOS</tag>
        <tag>Xcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[android:数据存储SharedPrefernces]]></title>
    <url>%2F2017%2F06%2F22%2FAndroid-%E5%9B%9B%E5%A4%A7%E7%BB%84%E4%BB%B6%E4%B9%8BSharedPrefernces%2F</url>
    <content type="text"><![CDATA[Android 四大组件之使用SharedPreferncesSharedPreferences到底是什么它是一个轻量级的存储类，特别适合用于保存软件配置参数。使用SharedPreferences保存数据，其背后是用xml文件存放数据，文件存放在/data/data/packagename/shared_prefs目录下： SharedPreferences使用12345SharedPreferences sharedPreferences = getSharedPreferences(&quot;testshare&quot;, Context.MODE_PRIVATE);Editor editor = sharedPreferences.edit();//获取编辑器editor.putString(&quot;name&quot;, &quot;kieran&quot;);editor.putBoolean(&quot;isboy&quot;, true);editor.commit();//提交修改 生成的testshare.xml文件内容如下： 12345&lt;?xml version=&apos;1.0&apos; encoding=&apos;utf-8&apos; standalone=&apos;yes&apos; ?&gt;&lt;map&gt;&lt;string name=&quot;name&quot;&gt;kieran&lt;/string&gt;&lt;boolean name=&quot;sex&quot;&gt;true&lt;/boolean&gt;&lt;/map&gt; 生成的文件路径 /data/data/packagename/shared_prefs/testshare.xml SharedPreferences获取一、 getSharedPreferences(String name, int mode)abstract SharedPreferences getSharedPreferences(String name, int mode) name为本组件的配置文件名( 自己定义，也就是一个文件名，不需要带后缀名，系统自己添加)，当这个文件不存在时，直接创建，如果已经存在，则直接使用， mode为操作模式，默认的模式为0或MODE_PRIVATE，还可以使用MODE_WORLD_READABLE和MODE_WORLD_WRITEABLE mode指定为MODE_PRIVATE，则该配置文件只能被自己的应用程序访问。mode指定为MODE_WORLD_READABLE，则该配置文件除了自己访问外还可以被其它应该程序读取。mode指定为MODE_WORLD_WRITEABLE，则该配置文件除了自己访问外还可以被其它应该程序读取和写入 二、PreferenceManager的方法getSharedPreferences() 可以通过查看其源码 1234567891011121314/** * Gets a SharedPreferences instance that preferences managed by this will * use. * * @return A SharedPreferences instance pointing to the file that contains * the values of preferences that are managed by this. */ public SharedPreferences getSharedPreferences() &#123; if (mSharedPreferences == null) &#123; mSharedPreferences = mContext.getSharedPreferences(mSharedPreferencesName, mSharedPreferencesMode); &#125; return mSharedPreferences; &#125; 12345678910111213/** * Gets a SharedPreferences instance that preferences managed by this will * use. * @return A SharedPreferences instance pointing to the file that contains * the values of preferences that are managed by this. */public SharedPreferences getSharedPreferences() &#123; if (mSharedPreferences == null) &#123; mSharedPreferences = mContext.getSharedPreferences(mSharedPreferencesName, mSharedPreferencesMode); &#125; return mSharedPreferences;&#125; 其构造方法 1234567891011121314151617181920212223242526272829303132/** * This constructor should ONLY be used when getting default values from * an XML preference hierarchy. * &lt;p&gt; * The &#123;@link PreferenceManager#PreferenceManager(Activity)&#125; * should be used ANY time a preference will be displayed, since some preference * types need an Activity for managed queries. */private PreferenceManager(Context context) &#123; init(context);&#125;private void init(Context context) &#123; mContext = context; setSharedPreferencesName(getDefaultSharedPreferencesName(context));&#125;/** * Sets the name of the SharedPreferences file that preferences managed by this * will use. * * @param sharedPreferencesName The name of the SharedPreferences file. * @see Context#getSharedPreferences(String, int) */public void setSharedPreferencesName(String sharedPreferencesName) &#123; mSharedPreferencesName = sharedPreferencesName; mSharedPreferences = null;&#125;private static String getDefaultSharedPreferencesName(Context context) &#123; return context.getPackageName() + &quot;_preferences&quot;;&#125; 由以上方法，我们可以知道，最终我们调用getSharedPreferences()方法得到的是一个名为”yourpackageName_preferences“的偏好。同时其mode为默认私有。 三、getDefaultSharedPreferences方法123456789101112/** * Gets a SharedPreferences instance that points to the default file that is * used by the preference framework in the given context. * * @param context The context of the preferences whose values are wanted. * @return A SharedPreferences instance that can be used to retrieve and * listen to values of the preferences. */public static SharedPreferences getDefaultSharedPreferences(Context context) &#123; return context.getSharedPreferences(getDefaultSharedPreferencesName(context), getDefaultSharedPreferencesMode());&#125; 12345678910111213/** * Returns the name used for storing default shared preferences. * * @see #getDefaultSharedPreferences(Context) * @see Context#getSharedPreferencesPath(String) */public static String getDefaultSharedPreferencesName(Context context) &#123; return context.getPackageName() + &quot;_preferences&quot;;&#125;private static int getDefaultSharedPreferencesMode() &#123; return Context.MODE_PRIVATE;&#125; 这个方法是静态的，因此可以直接调用，同时它与我们调用getSharedPreferences()方法得到的返回值是一样的，只是调用的方式不同罢了。 四、 getPreferences(mode) 方法123456789101112131415/** * Retrieve a &#123;@link SharedPreferences&#125; object for accessing preferences * that are private to this activity. This simply calls the underlying * &#123;@link #getSharedPreferences(String, int)&#125; method by passing in this activity&apos;s * class name as the preferences name. * * @param mode Operating mode. Use &#123;@link #MODE_PRIVATE&#125; for the default * operation. * * @return Returns the single SharedPreferences instance that can be used * to retrieve and modify the preference values. */public SharedPreferences getPreferences(int mode) &#123; return getSharedPreferences(getLocalClassName(), mode);&#125; 这个方法默认使用当前类类名作为文件的名称(不含包名) SharedPreferences 总结 SharedPreferences 存取数据使用的是xml 文件，系统对xml 文件进行了加载优化，当然也可以使用自定义其他方式的文件存取。 如果想让其他应用能够读写，可以指定Modle权限。12MODE_WORLD_READABLEMODE_WORLD_WRITEABLE 访问其他应用中的Preference（使用的应用 preference创建时指定了Context.MODE_WORLD_READABLE或者Context.MODE_WORLD_WRITEABLE ） 根据此应用的包名 创建Content 通过创建Content访问preference ，访问preference时会在应用所在包下的shared_prefs目录找到preference 1234Context otherAppsContext = createPackageContext(&quot;cn.kieran.action&quot;, Context.CONTEXT_IGNORE_SECURITY);SharedPreferences sharedPreferences = otherAppsContext.getSharedPreferences(&quot;testshare&quot;, Context.MODE_WORLD_READABLE);String name = sharedPreferences.getString(&quot;name&quot;, &quot;&quot;);int age = sharedPreferences.getBoolean(&quot;isboy&quot;, &quot;&quot;); 如果不通过创建Context访问其他应用的preference，也可以以读取xml文件方式直接访问其他应用preference对应的xml文件，如： 1File xmlFile = new File(“/data/data/cn.kieran.action/shared_prefs/testshare.xml”);。]]></content>
      <categories>
        <category>android</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[android :AndroidManifest.xml]]></title>
    <url>%2F2017%2F06%2F09%2Fandroid-%E5%85%A5%E9%97%A8%E7%AC%AC%E4%B8%80%E7%AB%A0%2F</url>
    <content type="text"><![CDATA[关于 AndroidManifest.xml是安装程序的必须文件，是整个项目的配置文件，对各个节点进行分析 第一层 Manifest : (属性)12345678&lt;manifest xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; package=&quot;com.roobo.test&quot; android:sharedUserId=&quot;string&quot; android:sharedUserLabel=&quot;string resource&quot; android:versionCode=&quot;integer&quot; android:versionName=&quot;string&quot; android:installLocation=[&quot;auto&quot; | &quot;internalOnly&quot; | &quot;preferExternal&quot;] &gt;&lt;/manifest&gt; xmlns:android 定义android命名空间，一般为http://schemas.android.com/apk/res/android， 这样使得Android中各种标准属性能在文件中使用，提供了大部分元素中的数据 package 指定本应用内java主程序包的包名，它也是一个应用程序的唯一标识符 sharedUserId Android给每个APK进程分配一个单独的用户空间,其manifest中的userid就是对应一个Linux用户(Android 系统是基于Linux)的.所以不同APK(用户)间互相访问数据默认是禁止的.但是它也提供了2种APK间共享数据的形式:相当于ios 的 URL Schemes(应用间跳转) sharedUserLabel 一个共享的用户名，它只有在设置了sharedUserId属性的前提下才会有意义 versionCode 是给设备程序识别版本(升级)用的必须是一个interger值代表app更新过多少次，比如第一版一般为1，之后若要更新版本就设置为2，3等等 versionName 这个名称是给用户看的,如当前的版本是 2.0.1 installLocation 安装参数，是Android2.2中的一个新特性，installLocation有三个值可以选择：internalOnly、auto、preferExternal 选择preferExternal,系统会优先考虑将APK安装到SD卡上(当然最终用户可以选择为内部ROM存储上，如果SD存储已满，也会安装到内部存储上) 选择auto，系统将会根据存储空间自己去适应 选择internalOnly是指必须安装到内部才能运行 (注：需要进行后台类监控的APP最好安装在内部，而一些较大的游戏APP最好安装在SD卡上。现默认为安装在内部，如果把APP安装在SD卡上，首先得设置你的level为8，并且要配置android:installLocation这个参数的属性为preferExternal) 第二层Application属性每个app 都必须声明当前配置标签,标签声明了每一个应用程序的组件及其属性(如icon,label,permission等)12345678910111213141516171819&lt;application android:allowClearUserData=[&quot;true&quot; | &quot;false&quot;] android:allowTaskReparenting=[&quot;true&quot; | &quot;false&quot;] android:backupAgent=&quot;string&quot; android:debuggable=[&quot;true&quot; | &quot;false&quot;] android:description=&quot;string resource&quot; android:enabled=[&quot;true&quot; | &quot;false&quot;] android:hasCode=[&quot;true&quot; | &quot;false&quot;] android:icon=&quot;drawable resource&quot; android:killAfterRestore=[&quot;true&quot; | &quot;false&quot;] android:label=&quot;string resource&quot; android:manageSpaceActivity=&quot;string&quot; android:name=&quot;string&quot; android:permission=&quot;string&quot; android:persistent=[&quot;true&quot; | &quot;false&quot;] android:process=&quot;string&quot; android:restoreAnyVersion=[&quot;true&quot; | &quot;false&quot;] android:taskAffinity=&quot;string&quot; android:theme=&quot;resource or theme&quot; &gt;&lt;/application&gt; android:allowClearUserData(‘true’ or ‘false’) 用户是否能选择自行清除数据，默认为true，程序管理器包含一个选择允许用户清除数据。当为true时，用户可自己清理用户数据，反之亦然 android:allowTaskReparenting(‘true’ or ‘false’) 是否允许activity更换从属的任务，比如从短信息任务切换到浏览器任务 android:backupAgent 设置该APP的备份，属性值应该是一个完整的类名，如com.project.TestCase，此属性并没有默认值，并且类名必须得指定(就是个备份工具，将数据备份到云端的操作) android:debuggable 这个从字面上就可以看出是什么作用的，当设置为true时，表明该APP在手机上可以被调试。默认为false,在false的情况下调试该APP，就会报以下错误： Device XXX requires that applications explicitely declare themselves as debuggable in their manifest. Application XXX does not have the attribute ‘debuggable’ set to TRUE in its manifest and cannot be debugged. android:description/android:label 此两个属性都是为许可提供的，均为字符串资源，当用户去看许可列表(android:label)或者某个许可的详细信息(android:description)时，这些字符串资源就可以显示给用户。label应当尽量简短，之需要告知用户该许可是在保护什么功能就行。而description可以用于具体描述获取该许可的程序可以做哪些事情，实际上让用户可以知道如果他们同意程序获取该权限的话，该程序可以做什么。我们通常用两句话来描述许可，第一句描述该许可，第二句警告用户如果批准该权限会可能有什么不好的事情发生 android:enabled Android系统是否能够实例化该应用程序的组件，如果为true，每个组件的enabled属性决定那个组件是否可以被 enabled。如果为false，它覆盖组件指定的值；所有组件都是disabled。 android:hasCode(‘true’ or ‘false’) 表示此APP是否包含任何的代码，默认为true，若为false，则系统在运行组件时，不会去尝试加载任何的APP代码 一个应用程序自身不会含有任何的代码，除非内置组件类，比如Activity类，此类使用了AliasActivity类，当然这是个罕见的现象 (在Android2.3可以用标准C来开发应用程序，可在androidManifest.xml中将此属性设置为false,因为这个APP本身已经不含有任何的JAVA代码了) android:icon 就是声明整个APP的图标，图片一般都放在drawable文件夹下 android:killAfterRestore 这个属性是指在一个完整的系统恢复操作之后应用程序是否被终止。单个应用程序的恢复操作不会引起应用程序的终止。完整的系统恢复操作一般仅在手机首次安装时才会发生一次。第三方应用通常都不需要使用该属性。 该属性的默认值为true，意为在完整的系统恢复期间，应用程序在结束处理其数据之后将被终止。 android:manageSpaceActivity 意思是用于指定一个Activity来管理数据，加上这个属性，指定SettingActivity为管理空间的Activity 123&lt;application android:manageSpaceActivity=&quot;.activity.SettingActivity&quot; &gt; &lt;/application&gt; android:name 为应用程序所实现的Application子类的全名。当应用程序进程开始时，该类在所有应用程序组件之前被实例化。 若该类(比方androidMain类)是在声明的package下，则可以直接声明android:name=”androidMain”,但此类是在package下面的子包的话，就必须声明为全路径或android:name=”package名称.子包名成.androidMain” android:permission 设置许可名，这个属性若在上定义的话，是一个给应用程序的所有组件设置许可的便捷方式，当然它是被各组件设置的许可名所覆盖的 android:presistent 该应用程序是否应该在任何时候都保持运行状态,默认为false。因为应用程序通常不应该设置本标识，持续模式仅仅应该设置给某些系统应用程序才是有意义的。 android:process 应用程序运行的进程名，它的默认值为元素里设置的包名，当然每个组件都可以通过设置该属性来覆盖默认值。如果你想两个应用程序共用一个进程的话，你可以设置他们的android:process相同，但前提条件是他们共享一个用户ID及被赋予了相同证书的时候 android:restoreAnyVersion 用来表明应用是否准备尝试恢复所有的备份，甚至该备份是比当前设备上更要新的版本，默认是false android:taskAffinity 拥有相同的affinity的Activity理论上属于相同的Task，应用程序默认的affinity的名字是元素中设定的package名 android:theme 是一个资源的风格，它定义了一个默认的主题风格给所有的activity,当然也可以在自己的theme里面去设置它，有点类似style。 第三层:属性1234567891011121314151617181920212223242526272829303132&lt;activity android:allowTaskReparenting=[&quot;true&quot; | &quot;false&quot;] android:alwaysRetainTaskState=[&quot;true&quot; | &quot;false&quot;] android:clearTaskOnLaunch=[&quot;true&quot; | &quot;false&quot;] android:configChanges=[&quot;mcc&quot;, &quot;mnc&quot;, &quot;locale&quot;, &quot;touchscreen&quot;, &quot;keyboard&quot;, &quot;keyboardHidden&quot;, &quot;navigation&quot;, &quot;orientation&quot;, &quot;screenLayout&quot;, &quot;fontScale&quot;, &quot;uiMode&quot;] android:enabled=[&quot;true&quot; | &quot;false&quot;] android:excludeFromRecents=[&quot;true&quot; | &quot;false&quot;] android:exported=[&quot;true&quot; | &quot;false&quot;] android:finishOnTaskLaunch=[&quot;true&quot; | &quot;false&quot;] android:icon=&quot;drawable resource&quot; android:label=&quot;string resource&quot; android:launchMode=[&quot;multiple&quot; | &quot;singleTop&quot; | &quot;singleTask&quot; | &quot;singleInstance&quot;] android:multiprocess=[&quot;true&quot; | &quot;false&quot;] android:name=&quot;string&quot; android:noHistory=[&quot;true&quot; | &quot;false&quot;] android:permission=&quot;string&quot; android:process=&quot;string&quot; android:screenOrientation=[&quot;unspecified&quot; | &quot;user&quot; | &quot;behind&quot; | &quot;landscape&quot; | &quot;portrait&quot; | &quot;sensor&quot; | &quot;nosensor&quot;] android:stateNotNeeded=[&quot;true&quot; | &quot;false&quot;] android:taskAffinity=&quot;string&quot; android:theme=&quot;resource or theme&quot; android:windowSoftInputMode=[&quot;stateUnspecified&quot;, &quot;stateUnchanged&quot;, &quot;stateHidden&quot;, &quot;stateAlwaysHidden&quot;, &quot;stateVisible&quot;, &quot;stateAlwaysVisible&quot;, &quot;adjustUnspecified&quot;, &quot;adjustResize&quot;, &quot;adjustPan&quot;] &gt; &lt;/activity&gt; *android:clearTaskOnLaunch 比如 P 是 activity, Q 是被P 触发的 activity, 然后返回Home, 重新启动 P，是否显示 Q *android:excludeFromRecents 是否可被显示在最近打开的activity列表里，默认是false android:finishOnTaskLaunch 当用户重新启动这个任务的时候，是否关闭已打开的activity，默认是false 如果这个属性和allowTaskReparenting都是true,这个属性就是王牌。Activity的亲和力将被忽略。该Activity已经被摧毁并非re-parented android:launchMode(Activity加载模式) 在多Activity开发中，有可能是自己应用之间的Activity跳转，或者夹带其他应用的可复用Activity。可能会希望跳转到原来某个Activity实例，而不是产生大量重复的Activity。这需要为Activity配置特定的加载模式，而不是使用默认的加载模式 Activity有四种加载模式： standard、singleTop、singleTask、singleInstance(其中前两个是一组、后两个是一组)，默认为standard standard：就是intent将发送给新的实例，所以每次跳转都会生成新的activity。 singleTop：也是发送新的实例，但不同standard的一点是，在请求的Activity正好位于栈顶时(配置成singleTop的Activity)，不会构造新的实例 singleTask：和后面的singleInstance都只创建一个实例，当intent到来，需要创建设置为singleTask的Activity的时候，系统会检查栈里面是否已经有该Activity的实例。如果有直接将intent发送给它。 singleInstance： 首先说明一下task这个概念，Task可以认为是一个栈，可放入多个Activity。比如启动一个应用，那么Android就创建了一个Task，然后启动这个应用的入口Activity，那在它的界面上调用其他的Activity也只是在这个task里面。那如果在多个task中共享一个Activity的话怎么办呢。举个例来说，如果开启一个导游服务类的应用程序，里面有个Activity是开启GOOGLE地图的，当按下home键退回到主菜单又启动GOOGLE地图的应用时，显示的就是刚才的地图，实际上是同一个Activity，实际上这就引入了singleInstance。singleInstance模式就是将该Activity单独放入一个栈中，这样这个栈中只有这一个Activity，不同应用的intent都由这个Activity接收和展示，这样就做到了共享。当然前提是这些应用都没有被销毁，所以刚才是按下的HOME键，如果按下了返回键，则无效 android:multiprocess 是否允许多进程，默认是false android:noHistory 当用户从Activity上离开并且它在屏幕上不再可见时，Activity是否从Activity stack中清除并结束。默认是false。Activity不会留下历史痕迹 android:screenOrientation activity显示的模式 默认为unspecified：由系统自动判断显示方向 landscape横屏模式，宽度比高度大 portrait竖屏模式, 高度比宽度大 user模式，用户当前首选的方向 behind模式：和该Activity下面的那个Activity的方向一致(在Activity堆栈中的) sensor模式：有物理的感应器来决定。如果用户旋转设备这屏幕会横竖屏切换nosensor模式：忽略物理感应器，这样就不会随着用户旋转设备而更改了 android:stateNotNeeded activity被销毁或者成功重启时是否保存状态 android:windowSoftInputMode activity主窗口与软键盘的交互模式，可以用来避免输入法面板遮挡问题，Android1.5后的一个新特性。 这个属性能影响两件事情： 【A】当有焦点产生时，软键盘是隐藏还是显示 【B】是否减少活动主窗口大小以便腾出空间放软键盘 各值的含义： 【A】stateUnspecified：软键盘的状态并没有指定，系统将选择一个合适的状态或依赖于主题的设置 【B】stateUnchanged：当这个activity出现时，软键盘将一直保持在上一个activity里的状态，无论是隐藏还是显示 【C】stateHidden：用户选择activity时，软键盘总是被隐藏 【D】stateAlwaysHidden：当该Activity主窗口获取焦点时，软键盘也总是被隐藏的 【E】stateVisible：软键盘通常是可见的 【F】stateAlwaysVisible：用户选择activity时，软键盘总是显示的状态 【G】adjustUnspecified：默认设置，通常由系统自行决定是隐藏还是显示 【H】adjustResize：该Activity总是调整屏幕的大小以便留出软键盘的空间 【I】adjustPan：当前窗口的内容将自动移动以便当前焦点从不被键盘覆盖和用户能总是看到输入内容的部分 第四层()1234567&lt;intent-filter android:icon=&quot;drawable resource&quot; android:label=&quot;string resource&quot; android:priority=&quot;integer&quot; &gt; &lt;action /&gt; &lt;category /&gt; &lt;data /&gt;&lt;/intent-filter&gt; intent-filter属性 android:priority(解释：有序广播主要是按照声明的优先级别，如A的级别高于B，那么，广播先传给A，再传给B。优先级别就是用设置priority属性来确定，范围是从-1000～1000，数越大优先级别越高) Intent filter内会设定的资料包括action,data与category三种。也就是说filter只会与intent里的这三种资料作对比动作 action属性 action很简单，只有android:name这个属性。常见的android:name值为android.intent.action.MAIN，表明此activity是作为应用程序的入口。有关android:name具体有哪些值，可参照这个网址：http://hi.baidu.com/linghtway/blog/item/83713cc1c2d053170ff477a7.html category属性 category也只有android:name属性。常见的android:name值为android.intent.category.LAUNCHER(决定应用程序是否显示在程序列表里) data属性 1234567&lt;data android:host=&quot;string&quot; android:mimeType=&quot;string&quot; android:path=&quot;string&quot; android:pathPattern=&quot;string&quot; android:pathPrefix=&quot;string&quot; android:port=&quot;string&quot; android:scheme=&quot;string&quot;/&gt; 【1】每个元素指定一个URI和数据类型（MIME类型）。它有四个属性scheme、host、port、path对应于URI的每个部分：scheme://host:port/path scheme的值一般为”http”，host为包名，port为端口号，path为具体地址。如：http://com.test.project:200/folder/etc 其中host和port合起来构成URI的凭据(authority)，如果host没有指定，则port也会被忽略 要让authority有意义，scheme也必须要指定。要让path有意义，scheme+authority也必须要指定 【2】mimeType（指定数据类型），若mimeType为’Image’，则会从content Provider的指定地址中获取image类型的数据。还有’video’啥的，若设置为video/mp4，则表示在指定地址中获取mp4格式的video文件 【3】而pathPattern和PathPrefix主要是为了格式化path所使用的]]></content>
      <categories>
        <category>android</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>开发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[cocoapod 笔记]]></title>
    <url>%2F2017%2F01%2F18%2Fcocoapod%2F</url>
    <content type="text"><![CDATA[设置gem为最新版本1sudo gem update --system pod 安装1234567891011121314151617181920$ gem update --system # 这里请翻墙一下$ gem sources --add https://gems.ruby-china.org/ --remove https://rubygems.org/$ gem sources -l# https://gems.ruby-china.org$ sudo gem install cocoapods sudo gem install -n /usr/local/bin cocoapods解决无安装权限$ pod setupcd ~/.cocoapodsdu -sh * cocoapod 私有库创建1pod lib create RBBusKit 1pod lib lint 12pod trunk push //提交公有pod trunk push --allow-warnings cocoapod 私有库12#podfile 文件路径pod repo add RBVideoSDK https://git.365jiating.com/zhikuiyu/RBVideoKit.git 1pod repo push RBVideoSDK RBVideoSDK.podspec 1pod lib lint --sources=git@git.365jiating.com:zhikuiyu/videoSpec.git,master --no-clean --verbose --allow-warnings 搜索不到内容1rm ~/Library/Caches/CocoaPods/search_index.json pod 注册123pod trunk register zhikuiyu@roo.bo &apos;zhikuiyu&apos; --description=&apos;zhikuiyu&apos;pod trunk register zky_416@sina.com &apos;zhikuiyu&apos; --description=&apos;zhikuiyu&apos; pod1234- ERROR | [iOS] unknown: Encountered an unknown error (757: unexpected token alaunchctl remove com.apple.CoreSimulator.CoreSimulatorServicekillall -9 com.apple.CoreSimulator.CoreSimulatorService]]></content>
      <categories>
        <category>IOS</category>
      </categories>
      <tags>
        <tag>开发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ios php push证书]]></title>
    <url>%2F2017%2F01%2F18%2Fios%20push%20%E8%AF%81%E4%B9%A6%2F</url>
    <content type="text"><![CDATA[IOS PhP 证书生成1openssl pkcs12 -nocerts -out PushChatKey.pem -in apns-dev-cert.p12 1openssl pkcs12 -clcerts -nokeys -out apns-dev-cert.pem -in apns-dev-cert.p12 1cat PushChatKey.pem apns-dev-cert.pem &gt; ck.pem]]></content>
      <categories>
        <category>工作笔记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[文件路径]]></title>
    <url>%2F2017%2F01%2F18%2F%E6%96%87%E4%BB%B6%E8%B7%AF%E5%BE%84%2F</url>
    <content type="text"><![CDATA[组件路径RBBusKit1/Users/zky/RBBusKit DeviceData 路径1/Users/roobo/Library/Developer/Xcode/DerivedData 清理编译缓存12//xcode 缓存地址~/Library/Developer/Xcode/Products]]></content>
      <categories>
        <category>IOS</category>
      </categories>
      <tags>
        <tag>开发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git 使用笔记]]></title>
    <url>%2F2017%2F01%2F18%2F%E8%A7%A3%E5%86%B3%E6%9C%AC%E5%9C%B0%E5%A4%9A%E4%B8%AAssh%20key%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[解决本地多个ssh key问题有的时候，不仅github使用ssh key，工作项目或者其他云平台可能也需要使用ssh key来认证，如果每次都覆盖了原来的id_rsa文件，那么之前的认证就会失效。这个问题我们可以通过在~/.ssh目录下增加config文件来解决。 下面以配置git oschina的ssh key为例。 生成ssh key时同时指定保存的文件名,这里也可以不用指定，只需要在创建的时候根据提示修改就可以，这里使用直接指定路径文件名的方式 ssh-keygen -t rsa -f ~/.ssh/oschina/id_rsa -C “email”这时~/.ssh目录下会多出oschina/id_rsa和oschina/id_rsa.pub两个文件，id_rsa.pub里保存的就是我们要使用的key。 新增并配置config文件 添加config文件 如果config文件不存在，先添加；存在则直接修改 touch ~/.ssh/config在config文件里添加如下内容(User表示你的用户名) Host git.oschina.net HostName git.oschina.net IdentityFile ~/.ssh/oschina/id_rsa User git 上传key到oschina http://git.oschina.net/profile/sshkeys 测试ssh key是否配置成功 ssh -T git@git.oschina.net成功的话会显示： Welcome to Git@OSC, 张大鹏!至此，本地便成功配置多个ssh key。日后如需添加，则安装上述配置生成key，并修改config文件即可。 ssh-keygen -t rsa -C “注册的github邮箱”终端执行命令：ssh-keygen -t rsa -C “注册的github邮箱”，这次一定要注意，对生成定的秘钥进行重命名，这里暂且重命名为id_rsa_home,同样不设置密码。可以看到生成的公私秘钥已经分别被重命名为id_rsa_home.pub和id_rsa_home。检测 配置config在.ssh/目录下新建config文件：touch config，通过nano编辑器进行如下配置：1234Host git.365jiating.com HostName git.365jiating.com IdentityFile ~/.ssh/roobo/id_rsa User git 检测gitlab连接，如果提示是否建立连接，直接yes就行： 检测github连接： 不报错的话，就说明设置成功了！ 步骤二：配置~/.ssh/config文件，以我自己的机器为例。1234567891011#Default GitHost defaultgit HostName IP Address #域名也可 User think IdentityFile ~/.ssh/id_rsa#Second GitHost secondgit HostName IP Address #域名也可 User think IdentityFile ~/.ssh/id_rsa_second 步骤三：执行ssh-agent让ssh识别新的私钥。1ssh-add ~/.ssh/id_rsa_new 该命令如果报错：Could not open a connection to your authentication agent.无法连接到ssh agent，可执行ssh-agent bash命令后再执行ssh-add命令。 也可以修改提交的用户名和Email：1git commit --amend --author=&apos;Your Name &apos;]]></content>
  </entry>
  <entry>
    <title><![CDATA[神奇的__attribute__]]></title>
    <url>%2F2017%2F01%2F12%2F%E7%A5%9E%E5%A5%87%E7%9A%84__attribute__%2F</url>
    <content type="text"><![CDATA[神奇的__attribute____attribute__是GNU C特色之一,在iOS用的比较广泛。如果你没有用过，那系统库你总用过，在Foundation.framework中有很多地方用到__attribute__特性。__attribute__ 可以设置函数属性（Function Attribute ）、变量属性（Variable Attribute ）和类型属性（Type Attribute）。接下来就从iOS中常见用法谈起。 format作用：编译器会检查格式化字符串与“…”的匹配情况，防止产生难以发现的Bug。__attribute__((format(printf,m,n)))__attribute__((format(scanf,m,n)))其中参数m与n的含义为：m 格式化字符串（format string）的位置（顺序从1开始）；n 参数“…”的位置（顺序从1开始）；123456789101112131415161718192021FOUNDATION_EXPORT NSLog(NSString *format, ...) NS_FORMAT_FUNCTION;#define NS_FORMAT_FUNCTION(F,A) __attribute__((format(__NSString__, F, A)))#define kMaxStringLen extern MyLog(const *tag,const *format,...) __attribute__((format(printf,,))); MyLog(const *tag,const *format,...) &#123; va_list ap; va_start(ap, format); * pBuf = (*)malloc(kMaxStringLen); (pBuf != ) &#123; vsnprintf(pBuf, kMaxStringLen, format, ap); &#125; va_end(ap); printf(&quot;TAG:%s Message:%s&quot;,tag,pBuf); (pBuf);&#125; deprecated作用：使编译会给出过时的警告。__attribute__((deprecated))__attribute__((deprecated(s)))123456#define DEPRECATED_ATTRIBUTE __attribute__((deprecated))#if __has_feature(attribute_deprecated_with_message) #define DEPRECATED_MSG_ATTRIBUTE __attribute__((deprecated))#else #define DEPRECATED_MSG_ATTRIBUTE __attribute__((deprecated))#endif availability作用：指明API版本的变更。__attribute__((availability(macosx,introduced=m,deprecated=n)))m 引入的版本n 过时的版本1#define CF_DEPRECATED_IOS(_iosIntro, _iosDep, ...) __attribute__((availability(,introduced=_iosIntro,deprecated=_iosDep,message= __VA_ARGS__))) unavailable作用：告诉编译器该方法不可用，如果强行调用编译器会提示错误。比如某个类在构造的时候不想直接通过init来初始化，只能通过特定的初始化方法，就可以将init方法标记为unavailable。__attribute__((unavailable))#define UNAVAILABLE_ATTRIBUTE __attribute__((unavailable)) 1234567891011121314#define NS_UNAVAILABLE UNAVAILABLE_ATTRIBUTE#import &lt;Foundation/Foundation.h&gt;@interface Person : NSObject@property(nonatomic,) NSString *name;@property(nonatomic,assign) NSUInteger age;- (instancetype)init NS_UNAVAILABLE;- (instancetype)initWithName:(NSString *)name age:(NSUInteger)age;@end const作用：用于带有数值类型参数的函数上。当重复调用带有数值参数的函数时，由于返回值是相同的，所以此时编译器可以进行优化处理，除第一次需要运算外， 其它只需要返回第一次的结果就可以了，进而可以提高效率。该属性主要适用于没有静态状态和副作用的一些函数，并且返回值仅仅依赖输入的参数。（const参数不能用在带有指针类型参数的函数中，因为该属性不但影响函数的参数值，同样也影响到了参数指向的数据，它可能会对代码本身产生严重甚至是不可恢复的严重后果。）__attribute__((const))add( x)1234567891011121314151617181920212223242526&#123; printf(&quot;%s(%d)\n&quot;, __FUNCTION__, x); return x + ;&#125;&#123; printf(&quot;%s(%d)\n&quot;, __FUNCTION__, x); return x + ;&#125; ( argc, * argv[])&#123; i, j; i = add(); j = add(); printf(&quot;%d %d\n&quot;, i, j); i = add2(); j = add2(); printf(&quot;%d %d\n&quot;, i, j); return ;&#125; cleanup作用：离开作用域之后执行指定的方法。实际应用中可以在作用域结束之后做一些特定的工作，比如清理。用法 ：__attribute__((cleanup(...)))12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455static stringCleanUp(__strong NSString **string) &#123; NSLog(@, *string);&#125; testCleanUp &#123; __strong NSString *string __attribute__((cleanup(stringCleanUp))) = @&quot;stringCleanUp&quot;;&#125;static blockCleanUp(__strong (^ *block)) &#123; (*block) &#123; (*block)(); &#125;&#125; testBlockCleanUp &#123; __strong (^block) __attribute__((cleanup(blockCleanUp))) = ^&#123; NSLog(@&quot;block&quot;); &#125;;&#125;static lambdaCleanUp( (**lambda)) &#123; (*lambda) &#123; (*lambda)(); &#125;&#125; testLambdaCleanUp &#123; (*lambda)() __attribute__((cleanup(lambdaCleanUp))) = []() &#123; (&quot;lambda&quot;); &#125;;&#125; ( argc, * argv[]) &#123; @autoreleasepool &#123; testCleanUp(); testBlockCleanUp(); testLambdaCleanUp(); &#125; return ;&#125;//结合宏定义使用#define BlockCleanUp __strong void(^block)() __attribute__((cleanup(blockCleanUp))) = ^#define LambdaCleanUp void (*lambda)() __attribute__((cleanup(lambdaCleanUp))) = []() testDefine &#123; BlockCleanUp &#123; (&quot;BlockCleanUp&quot;); &#125;; LambdaCleanUp&#123; (&quot;LambdaCleanUp&quot;); &#125;;&#125; constructor与destructor作用：__attribute__((constructor)) 在main函数之前执行,__attribute__((destructor)) 在main函数之后执行。__attribute__((constructor(PRIORITY)))和__attribute__((destructor(PRIORITY)))按优先级执行。（可用于动态库注入的Hook）用法：__attribute__((constructor))__attribute__((destructor))__attribute__((constructor(PRIORITY)))__attribute__((destructor(PRIORITY)))PRIORITY 为优先级123456789101112131415__attribute__((constructor)) start() &#123; NSLog(@,__FUNCTION__);&#125; __attribute__((destructor)) end() &#123; NSLog(@,__FUNCTION__);&#125;void main( argc, * argv[]) &#123; NSLog(@,__FUNCTION__); return ;&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647__attribute__((constructor)) start() &#123; NSLog(@&quot;%s&quot;,__FUNCTION__);&#125; __attribute__((constructor())) start100() &#123; NSLog(@&quot;%s&quot;,__FUNCTION__);&#125; __attribute__((constructor())) start101() &#123; NSLog(@&quot;%s&quot;,__FUNCTION__);&#125; __attribute__((destructor)) end() &#123; NSLog(@&quot;%s&quot;,__FUNCTION__);&#125; __attribute__((destructor)) end100() &#123; NSLog(@&quot;%s&quot;,__FUNCTION__);&#125; __attribute__((destructor)) end101() &#123; NSLog(@&quot;%s&quot;,__FUNCTION__);&#125; main( argc, * argv[]) &#123; NSLog(@&quot;%s&quot;,__FUNCTION__); return ;&#125;``` ![](https://kuiyu-1258489344.cos.ap-chengdu.myqcloud.com/%E7%A5%9E%E5%A5%87%E7%9A%84__attribute__/printlog2.png)## noreturn作用：定义有返回值的函数时，而实际情况有可能没有返回值，此时编译器会报错。加上attribute((noreturn))则可以很好的处理类似这种问题。用法：`__attribute__((noreturn))` `__attribute__((noreturn)) onExit();```` ( state) &#123; (state == ) &#123; onExit(); &#125; &#123; return ; &#125;&#125; nonnull作用：编译器对函数参数进行NULL的检查用法：__attribute__((nonnull(...)))1234567891011121314151617extern *my_memcpy_2 ( *dest, const *src, size_t len) __attribute__((nonnull (, )));extern *my_memcpy_3 ( *dest, const *src, const *other, size_t len) __attribute__((nonnull (, , ))); test_my_memcpy &#123; my_memcpy_2(, , ); my_memcpy_3(, , , );&#125;``` ![](https://kuiyu-1258489344.cos.ap-chengdu.myqcloud.com/%E7%A5%9E%E5%A5%87%E7%9A%84__attribute__/my_memcpy2.png)## aligned 与 packed作用：`aligned(m)` 将强制编译器尽其所能地确保变量在分配空间时采用m字节对齐方式。`packed`该属性对`struct` 或者`union` 类型进行定义，设定其类型的每一个变量的内存约束，当用在`enum` 类型定义时，暗示了应该使用最小完整的类型。`aligned` 属性使被设置的对象占用更多的空间，使用`packed` 可以减小对象占用的空间。用法： `attribute ((aligned (m)))``attribute ((aligned))``attribute ((packed))` //运行在iPhone5模拟器上struct p { a; b; short c;}attribute((aligned())) pp; struct m { a; b; short c;}attribute((aligned())) mm; struct o { a; b; short c;}oo; struct x { a; b; struct p px; short c; }attribute((aligned())) xx; struct MyStruct { c; i; short s;}attribute ((packed)); struct MyStruct1 { c; i; short s;}attribute ((aligned)); struct MyStruct2 { c; i; short s;}attribute ((aligned())); struct MyStruct3 { c; i; short s;}attribute ((aligned())); struct MyStruct4 { c; i; short s;}attribute ((aligned())); ( argc, * argv[]) { printf(&quot;sizeof(int)=%lu,sizeof(short)=%lu.sizeof(char)=%lu\n&quot;,sizeof(),sizeof(short),sizeof()); printf(&quot;pp=%lu,mm=%lu \n&quot;, sizeof(pp),sizeof(mm)); printf(&quot;oo=%lu,xx=%lu \n&quot;, sizeof(oo),sizeof(xx)); printf(&quot;mystruct=%lu \n&quot;, sizeof(struct MyStruct)); printf(&quot;mystruct1=%lu \n&quot;, sizeof(struct MyStruct1)); printf(&quot;mystruct2=%lu \n&quot;, sizeof(struct MyStruct2)); printf(&quot;mystruct3=%lu \n&quot;, sizeof(struct MyStruct3)); printf(&quot;mystruct4=%lu \n&quot;, sizeof(struct MyStruct4)); @autoreleasepool { return UIApplicationMain(argc, argv, nil, NSStringFromClass([AppDelegate class])); } }`参考资料：http://nshipster.com/__attribute__/]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>tag</tag>
      </tags>
  </entry>
</search>
